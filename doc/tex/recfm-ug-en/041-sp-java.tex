\section{Java source code generation --- \texttt{java-addon}} 
\label{sec:java.addon}
%--------1---------2---------3---------4---------5---------6---------7---------8
The classes generated by the java \textsl{CodeProvider} in addition to the 
setters and getters have a series of auxiliary methods, see 
lst.~\ref{lst:Foo312:java}.

%--------1---------2---------3---------4---------5---------6---------7---------8
\begin{itemize}\setlength\itemsep{-0.5ex}
\item a no-argument constructor is provided, which creates the class with 
    default values;
\item a cast-like constructor is provided, which takes any other class 
    representing a data-class as an argument;
\item a constructor is provided from string-data (deserializer);
\item a \textit{deep-copy} method is provided to duplicate the data-class;
\item a validation method is provided;
\item a \texttt{toString} method is provided;
\item a method is provided to generate the data-string (serializer);
\item a method is provided to retrieve the length of the data-string.
\end{itemize}

\begin{elisting}[!htb]
\begin{javacode}
public class Foo312 extends FixRecord {
    public Foo312() { /* ... */ }
    public static Foo312 of(FixRecord r) { /* ... */ }
    public static Foo312 decode(String s) { /* ... */ }
    public Foo312 copy() { /* ... */ }
    // setter and getter ...
    public boolean validateFails(|\hyperref[lst:FieldValidateHandler:java]{FieldValidateHandler}| handler) { /* ... */ }
    public boolean validateAllFails(|\hyperref[lst:FieldValidateHandler:java]{FieldValidateHandler}| handler) { /* ... */ }
    public String toString() { /* ... */ }
    public String encode() { /* ... */ }    // from super class
    public int length() { return LRECL; }   // string-data length
}
\end{javacode}
\caption{example of generated class (Foo312)}
\label{lst:Foo312:java}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Classes generated from configuration files inherit general classes with common 
methods for handling control setter/getter and validations. These classes are 
provided as an external library, see~\ref{lst:mvn-j-deps}.

\begin{elisting}[!htb]
\begin{xmlcode}
<dependencies>
  <dependency>
    <groupId>io.github.epi155</groupId>
    <artifactId>recfm-java-lib</artifactId>
    <version>0.7.0</version>
  </dependency>
</dependencies>
\end{xmlcode}
\caption{addon-java runtime dependencies}
\label{lst:mvn-j-deps}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
These libraries are compiled in java-5 compatibility, and contain the 
\textsl{module-info} in order to be correctly managed also with java-9 and 
higher.

\subsection{Validation}
%--------1---------2---------3---------4---------5---------6---------7---------8
As seen in the lst.~\ref{lst:Foo312:java} a validation method is generated for 
each class. 
The argument is a dedicated interface, but this is for pre-java-8 compatibility. 
The argument will be a \textit{closure}, implemented with an anonymous or 
internal class or a $\lambda$-function.

\begin{elisting}[!htb]
\begin{javacode}
public interface FieldValidateHandler {
    void error(|\hyperref[lst:FieldValidateError:java]{FieldValidateError}| fieldValidateError);
}
\end{javacode}
\caption{error handler \texttt{FieldValidateHandler}}
\label{lst:FieldValidateHandler:java}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The validation methods indicate whether the data-string acquired with the 
\texttt{decode} static constructor has passed the validation required by the 
definition of the fields or not, but every time a validation error is detected 
the \texttt{error} method of the interface supplied as an argument is called 
with the details of the error. In this way it is possible to accumulate all the 
validation errors detected. 
%--------1---------2---------3---------4---------5---------6---------7---------8
The difference between the two methods is that the first \texttt{validateFails} 
in case of multiple wrong characters on the same field, signals only the first, 
while the second \texttt{validateAllFails} signals all the characters in error.

\begin{elisting}[!htb]
\begin{javacode}
public interface FieldValidateError {
    String name();          // field name in error
    int offset();           // field offset in error
    int length();           // field length in error
    String value();         // field value in error
    Integer column();       // column of the record with the wrong character
    |\hyperref[lst:ValidateError:java]{ValidateError}| code();   // error category
    Character wrong();      // wrong character
    String message();       // field message error
}
\end{javacode}
\caption{error detail \texttt{FieldValidateError}}
\label{lst:FieldValidateError:java}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The argument to the \texttt{error} method is the \texttt{FieldValidateError} 
interface, which is basically a java-bean that only exposes getters in 
\textit{fluent} format. 
%--------1---------2---------3---------4---------5---------6---------7---------8
Please note that some values may be \texttt{null}. A field of type constant has 
no name. A field of type constant or domain or custom with a control set with a 
regular expression does not have a wrong character in a precise column. 
In the error message, if it is possible to identify the character in error, the 
position of the character relative to the field (not to the data-string) is 
shown, the character (if it is a control character the unicode encoding is 
shown), the \textit{name} of the character, and type of error; otherwise the 
value of the field and the type of error are shown.

\begin{elisting}[!htb]
\begin{javacode}
public enum ValidateError {
    NotNumber, NotAscii, NotLatin, NotValid, NotDomain, NotBlank, NotEqual, NotMatch, NotDigitBlank
}
\end{javacode}
\caption{error category \texttt{ValidateError}}
\label{lst:ValidateError:java}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Possible error types are shown in lst.~\ref{lst:ValidateError:java}, the meaning 
is evident from the name.

\subsection{Setters and getters}
%--------1---------2---------3---------4---------5---------6---------7---------8
The data-class implementation used by this library does not actually generate 
deserialized fields. When the class is created from the data-string, the static 
constructor just internally saves the data-string as an array of characters. 
The getter of a field accesses the range of characters corresponding to the 
field and deserializes them on the fly. 
Similarly the setter serializes the supplied value and copies it in the range of 
characters corresponding to the field. 
In this way it is trivial to \textsl{override} a field, the \textit{cast-like} 
constructor and \textit{deep-copy} are almost free of cost. 
The \textsl{encode} and \textsl{decode} methods are also basically free of cost 
because the serialization/deserialization operations are actually performed by 
the setters/getters.

\subsection{Single fields}
\subsubsection*{\texttt{null} value handling}
%--------1---------2---------3---------4---------5---------6---------7---------8
A null value cannot be represented in a data-string, unless conventionally this 
value is assigned to a particular string, as in fields of the numeric-nullable 
type. 
When a setter formally sets the \texttt{null} value, in the data-string 
representation it will actually be assigned the default value of the field: 
space for an alphanumeric type, zero for a numeric type, the \texttt{initChar} 
for a custom type, and the first value between those defined as possible for a 
domain field.

\begin{elisting}[!htb]
\begin{javacode}
    String getValue() { /* ... */ }   // string getter
    int intValue() { /* ... */ }      // int getter
\end{javacode}
\caption{Access to numeric values such as strings and primitive numbers}
\label{lst:num.acc.both}
\end{elisting}

\subsubsection*{\texttt{Both} access for numeric fields}
%--------1---------2---------3---------4---------5---------6---------7---------8
Numeric fields can be handled as strings of numeric characters or as primitive 
numeric objects. Fields can be configured to have getters/setters of type string 
or primitive numeric or both. 
If ``both'' is chosen, it is not possible to define the getter with the 
canonical name for both types. 
In this case the canonical name is used for the getter of type string, 
the getter with the primitive type has as its name the primitive type and the 
field name, see~\ref{lst:num.acc.both}.

\begin{elisting}[!htb]
\begin{quote}
\begin{minted}[frame=single,framesep=2mm,bgcolor=bg,fontsize=\footnotesize,linenos,firstnumber=200]{java}
    @Test
    void testDomain() {
        BarDom dom = new BarDom();
        dom.setCur("AAA");
    }
\end{minted}
\end{quote}
\vspace*{-1cm}
\begin{javacode}
io.github.epi155.recfm.java.NotDomainException: com.example.BarDom.setCur, offending value "AAA"
	at com.example.test.TestBar.testDomain(TestBar.java:203)
	...
\end{javacode}
\caption{Exception on the setter}
\label{lst:set.throw}
\end{elisting}

\subsubsection*{Controls on setters and getters}
%--------1---------2---------3---------4---------5---------6---------7---------8
If the checks on the setters are active and an illegal value is set, an 
exception is thrown which signals the violation of the check. The exception 
places the stacktrace on the setter instruction.

\begin{elisting}[!htb]
\begin{quote}
\begin{minted}[frame=single,framesep=2mm,bgcolor=bg,fontsize=\footnotesize,linenos,firstnumber=300]{java}
    @Test
    void testDomain() {
        BarDom d1 = BarDom.decode("AAA");
        String cur = d1.getCur();
    }
\end{minted}
\end{quote}
\vspace*{-1cm}
\begin{javacode}
io.github.epi155.recfm.java.NotDomainException: com.example.BarDom.getCur, offending value "AAA" @1+3
	at com.example.test.TestBar.testDomain(TestBar.java:303)
	...
\end{javacode}
\caption{Exception on the getter}
\label{lst:get.throw}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
Similarly on getters. If the data-string contains an invalid value for the field 
in the area corresponding to a field, the validation of the structure, which 
would have signaled the problem, is not performed, and the code continues until 
the getter, an exception is thrown. The exception places the stacktrace on the 
getter instruction.

\subsection{Manifold Fields}
%--------1---------2---------3---------4---------5---------6---------7---------8
n this context we will consider repeating fields only those fields of type group 
or repeated group, defined directly or through an interface. 
This type of fields generates an intermediate element. 
As seen from lst.~\ref{lst:grp.indef}, generated for a group defined via an 
interface, an internal class is created to manage the intermediate element, a 
private field with an instance of the intermediate element, a fluent getter of 
the field, and a \textit{Consumer} of the field.

\begin{elisting}[!htb]
\begin{javacode}
    public class StopTime implements Validable, ITime {/* ... */}
    private final StopTime stopTime = this.new StopTime();
    public StopTime stopTime() { return this.stopTime; }
    public void withStopTime(WithAction<StopTime> action) { action.accept(this.stopTime); }
\end{javacode}
\caption{Implementation of a group inside the data-class}
\label{lst:grp.indef}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The inner class will implement the validation interface, and, if defined via 
interface, the interface with the detail definition of the fields of the inner 
class. Each group can be validated individually as if it were a data-class.
The validation interface, \texttt{Validable}, requires the 
\texttt{validateFails} and \texttt{validateAllFails} method that we have already 
encountered in data-class validation. 
All data-classes also implement the \texttt{Validable} interface.

\begin{elisting}[!htb]
\begin{javacode}
public interface Validable {
    boolean validateFails(FieldValidateHandler handler);
    boolean validateAllFails(FieldValidateHandler handler);
}
\end{javacode}
\caption{Validation interface, at class-data and group level}
\label{lst:if.validable}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Defining a repeating group is similar to defining a group. An inner class is 
created to handle the repeating intermediate element, a private field with $n$ 
instances of the intermediate element, a fluent getter with an index of the 
field, and a \textit{Consumer} with index of the field.

\begin{elisting}[!htb]
\begin{javacode}
    public class TabError implements Validable, IError {/* ... */}
    private final TabError[] tabError = new TabError[] {
        this.new TabError(0),
        /* ... */
    };
    public TabError tabError(int k) { return this.tabError[k-1]; }
    public void withTabError(int k, WithAction<TabError> action) { action.accept(this.tabError[k-1]); }
\end{javacode}
\caption{Implementation of a repeating group inside the data-class}
\label{lst:occ.indef}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Also in this case the inner class that defines the intermediate element 
implements the validation interface, and, if defined through an interface, the 
interface with the definition of the detail of the fields of the inner class.
