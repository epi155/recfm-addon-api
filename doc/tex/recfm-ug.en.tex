\documentclass[a4paper,10pt]{report}

\usepackage[english]{babel}     % sillabazione italiana
\usepackage[body={17.8cm,24.7cm}]{geometry}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{pifont}
\usepackage{array,multirow}

\usepackage{makeidx}
\usepackage{tocloft}
\usepackage{fbox}

\usepackage{eflowchart}	% custom style

\newif\ifesource
%\esourcetrue
\ifesource
\usepackage{esourcecode}	% custom style
\else
\usepackage{xcolor,colortbl}
%\usepackage[outputdir={/tmp}]{minted}
\usepackage{minted}
\definecolor{bg}{rgb}{0.95,0.95,0.92}
\usepackage{caption}
\newenvironment{elisting}[1][H]
%  {\captionsetup{aboveskip=-0.1\normalbaselineskip}\begin{listing}[#1]}
  {\captionsetup{aboveskip=0pt}\begin{listing}[#1]}
  {\end{listing}%
}
\newminted{java}{
  frame=single,
  framesep=2mm,
  bgcolor=bg,
  fontsize=\footnotesize,
  escapeinside=||,
    tabsize=4,
%    fontfamily=courier,
    autogobble,
%    xleftmargin=5pt,
%    xrightmargin=5pt,
%    frame=lines,
}
\newminted{yaml}{
  frame=single,
  framesep=2mm,
  bgcolor=bg,
  fontsize=\footnotesize,
    tabsize=4,
%    fontfamily=courier,
    autogobble,
%    xleftmargin=5pt,
%    xrightmargin=5pt,
%    frame=lines,
}
\fi
\newminted{xml}{
  frame=single,
  framesep=2mm,
  bgcolor=bg,fontsize=\footnotesize,
  tabsize=4,
  autogobble,
}

%\usepackage[pdftex]{graphicx}

\usepackage[pdftex,
%pdftitle={Graphics and Color with LaTeX},
%pdfauthor={Patrick W Daly},
%pdfsubject={Importing images and use of color in LaTeX},
%pdfkeywords={LaTeX, graphics, color},
pdfpagemode=UseOutlines,
bookmarks,bookmarksopen,
pdfstartview=FitH,
colorlinks,linkcolor=blue,citecolor=blue,
urlcolor=green,
]
{hyperref}
\usepackage[nolink]{qrcode}

\renewcommand{\arraystretch}{1.2}

\usepackage{tikz}
%\usetikzlibrary{shapes,arrows}
%\usetikzlibrary{arrows,shapes,snakes,automata,backgrounds,petri}
\usetikzlibrary{arrows,shapes,decorations,automata,backgrounds,petri}

%\usepackage{bera}
%\usepackage{beraserif}
%\usepackage{berasans}
%\usepackage[scaled=0.9]{beramono}
\usepackage{newcent}
\usepackage[scaled=0.9]{beramono}
%\usepackage{bookman}
%\usepackage{dejavu}
%\usepackage{roboto}

\title{RECFM}
%\author{E.~Pistolesi}
%\author{\qrcode{Enrico Pistolesi}}

\makeindex
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}	% default is 2

\cftsetindents{section}{0.5in}{0.5in}
\cftsetindents{subsection}{0.5in}{0.6in}
\cftsetindents{subsubsection}{0.5in}{0.7in}
%\cftsetindents{paragraph}{0.5in}{0.5in}
\cftsetindents{table}{0.25in}{0.5in}

\ifesource
\cftsetindents{listings}{0.25in}{0.5in}
%\renewcommand{\lstlistlistingname}{Elenco dei sorgenti}
\else
%\renewcommand{\listingscaption}{Sorgente}
%\renewcommand{\listoflistingscaption}{Elenco dei sorgenti}
%\captionsetup[listing]{aboveskip=-50pt,belowskip=-20pt}
\fi


%--- begin - document ---------------------------------------------------------
\begin{document}

\begin{titlepage}
\newlength{\drop}% for my convenience
\drop=0.1\textheight
\centering
\settowidth{\unitlength}{\large\itshape xxxCode generation to handle positional filesxx}
\vspace*{\baselineskip}
\qrcode{Enrico Pistolesi}\\[\baselineskip]
%{\large\scshape E.~Pistolesi}\\[\baselineskip]
\rule{\unitlength}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}
\rule{\unitlength}{0.4pt}\\[\baselineskip]
{\Huge RECFM User Guide}\\[\baselineskip]
{\large\itshape Code generation to handle positional files}\\[0.2\baselineskip]
\rule{\unitlength}{0.4pt}\vspace*{-\baselineskip}\vspace{3.2pt}
\rule{\unitlength}{1.6pt}\\[\baselineskip]
%{\large\scshape drawings by the artist}\par
\vfill
{\large\scshape Version 0.7.0}\\[\baselineskip]
{\small\scshape \today}\par
\vspace*{\drop}
\end{titlepage}


\section*{Introduction}
%--------1---------2---------3---------4---------5---------6---------7---------8
Sometimes it may happen that you have to deal with positional files (or memory 
areas), see fig.~\ref{fig:str.data}, in these cases you need to waste a lot of 
time to make a class dedicated to each string-data with the setters and getters
to read and write values\footnote{%
there is \texttt{com.ancientprogramming.fixedformat4j:fixedformat4j} 
which provides some basic functionality, but in most situations it is not 
flexible enough.}.

\begin{figure}[!htb]
\centering\small
\scalebox{0.7}[1]{
\texttt{%
\fbox[lb]{S}%01
\fbox[lb]{C}%02
\fbox[lb]{A}%03
\fbox[lb]{R}%04
\fbox[lb]{L}%05
\fbox[lb]{E}%06
\fbox[lb]{T}%07
\fbox[lb]{T}%08
\fbox[lb]{ }%09
\fbox[lb]{ }%10
\fbox[lb]{ }%11
\fbox[lb]{ }%12
\fbox[lb]{ }%13
\fbox[lb]{ }%14
\fbox[lb]{ }%15
\fbox[lb]{J}%16
\fbox[lb]{O}%17
\fbox[lb]{H}%18
\fbox[lb]{A}%19
\fbox[lb]{N}%20
\fbox[lb]{S}%21
\fbox[lb]{S}%22
\fbox[lb]{O}%23
\fbox[lb]{N}%24
\fbox[lb]{ }%25
\fbox[lb]{ }%26
\fbox[lb]{ }%27
\fbox[lb]{ }%28
\fbox[lb]{ }%29
\fbox[lb]{ }%30
\fbox[lb]{1}%31
\fbox[lb]{9}%32
\fbox[lb]{8}%33
\fbox[lb]{4}%34
\fbox[lb]{1}%35
\fbox[lb]{1}%36
\fbox[lb]{2}%37
\fbox[lb]{2}%38
\fbox[lb]{N}%39
\fbox[lb]{E}%40
\fbox[lb]{W}%31
\fbox[lb]{ }%32
\fbox[lb]{Y}%33
\fbox[lb]{O}%34
\fbox[lb]{R}%35
\fbox[lb]{K}%36
\fbox[lb]{ }%37
\fbox[lb]{ }%38
\fbox[lb]{ }%39
\fbox[lb]{ }%40
\fbox[lb]{ }%41
\fbox[lb]{ }%42
\fbox[lb]{U}%43
\fbox[lb]{S}%44
\fbox[lbr]{A}%45
}}

\iffalse
\scalebox{0.7}[1]{
\texttt{%
\fbox[lb]{O}%01
\fbox[lb]{L}%02
\fbox[lb]{G}%03
\fbox[lb]{A}%04
\fbox[lb]{ }%05
\fbox[lb]{ }%06
\fbox[lb]{ }%07
\fbox[lb]{ }%08
\fbox[lb]{ }%09
\fbox[lb]{ }%10
\fbox[lb]{ }%11
\fbox[lb]{ }%12
\fbox[lb]{ }%13
\fbox[lb]{ }%14
\fbox[lb]{ }%15
\fbox[lb]{K}%16
\fbox[lb]{U}%17
\fbox[lb]{R}%18
\fbox[lb]{Y}%19
\fbox[lb]{L}%20
\fbox[lb]{E}%21
\fbox[lb]{N}%22
\fbox[lb]{K}%23
\fbox[lb]{O}%24
\fbox[lb]{ }%25
\fbox[lb]{ }%26
\fbox[lb]{ }%27
\fbox[lb]{ }%28
\fbox[lb]{ }%29
\fbox[lb]{ }%30
\fbox[lb]{1}%31
\fbox[lb]{9}%32
\fbox[lb]{7}%33
\fbox[lb]{9}%34
\fbox[lb]{1}%35
\fbox[lb]{1}%36
\fbox[lb]{1}%37
\fbox[lb]{4}%38
\fbox[lb]{B}%39
\fbox[lb]{E}%40
\fbox[lb]{R}%31
\fbox[lb]{D}%32
\fbox[lb]{J}%33
\fbox[lb]{A}%34
\fbox[lb]{N}%35
\fbox[lb]{S}%36
\fbox[lb]{'}%37
\fbox[lb]{K}%38
\fbox[lb]{ }%39
\fbox[lb]{ }%40
\fbox[lb]{ }%41
\fbox[lb]{ }%42
\fbox[lb]{U}%43
\fbox[lb]{K}%44
\fbox[lbr]{R}%45
}}
\fi

\scalebox{0.7}[1]{
\texttt{%
\fbox[lb]{A}%01
\fbox[lb]{N}%02
\fbox[lb]{A}%03
\fbox[lb]{ }%04
\fbox[lb]{ }%05
\fbox[lb]{ }%06
\fbox[lb]{ }%07
\fbox[lb]{ }%08
\fbox[lb]{ }%09
\fbox[lb]{ }%10
\fbox[lb]{ }%11
\fbox[lb]{ }%12
\fbox[lb]{ }%13
\fbox[lb]{ }%14
\fbox[lb]{ }%15
\fbox[lb]{D}%16
\fbox[lb]{E}%17
\fbox[lb]{ }%18
\fbox[lb]{A}%19
\fbox[lb]{R}%20
\fbox[lb]{M}%21
\fbox[lb]{A}%22
\fbox[lb]{S}%23
\fbox[lb]{ }%24
\fbox[lb]{ }%25
\fbox[lb]{ }%26
\fbox[lb]{ }%27
\fbox[lb]{ }%28
\fbox[lb]{ }%29
\fbox[lb]{ }%30
\fbox[lb]{1}%31
\fbox[lb]{9}%32
\fbox[lb]{8}%33
\fbox[lb]{8}%34
\fbox[lb]{0}%35
\fbox[lb]{4}%36
\fbox[lb]{3}%37
\fbox[lb]{0}%38
\fbox[lb]{H}%39
\fbox[lb]{A}%40
\fbox[lb]{V}%31
\fbox[lb]{A}%32
\fbox[lb]{N}%33
\fbox[lb]{A}%34
\fbox[lb]{ }%35
\fbox[lb]{ }%36
\fbox[lb]{ }%37
\fbox[lb]{ }%38
\fbox[lb]{ }%39
\fbox[lb]{ }%40
\fbox[lb]{ }%41
\fbox[lb]{ }%42
\fbox[lb]{C}%43
\fbox[lb]{U}%44
\fbox[lbr]{B}%45
}}

\caption{Positional data-file example} 
\label{fig:str.data}
\end{figure}



%--------1---------2---------3---------4---------5---------6---------7---------8
This group of programs aims to minimize the time to create these classes. 
In practice, the structure of the data-string is defined with a configuration 
file, this is fed to a plugin that generates the corresponding data-class, 
which can be used without anything else user intervention.

%--------1---------2---------3---------4---------5---------6---------7---------8
Programs are structured using service provider interface, see 
fig.~\ref{fig:spi}, we have a plugin, or user program (\textsl{Service}), which 
directly sees the classes defined in the \textsl{Service Provider Interface} and 
retrieves them the implementation using the \textsl{ServiceLoader}, this way it 
doesn't have a specific dependency with one of the the implementations used. 
The \textsl{Service Provider} must implement the classes defined in the 
\textsl{Service Provider Interface}.

\begin{figure}[!htb]
\centering
\begin{tikzpicture}[>=latex,font={\sf}]
\node(u1) at (0,1.5) [manual input,text width=2cm,fill=blue!10]{maven plugin};
\node(u2) at (3,1.5) [manual input,text width=2cm,fill=blue!10]{gradle plugin};
\node(u3) at (6,1.5) [manual input,text width=2cm,fill=blue!10]{custom service};
\node(si) at (3,0.0) [preparation,fill=yellow!20]{addon-api};
\node(a1) at (0,-1.5) [process,text width=1.7cm,fill=green!10]{java addon};
\node(a2) at (3,-1.5) [process,text width=1.7cm,fill=green!10]{scala addon};
\node(a3) at (6,-1.5) [process,text width=1.7cm,fill=green!10]{custom provider};

\node at (9,1.5) {Service};
\node at (9,0.0) {Service Provider Interface};
\node at (9,-1.5) {Service Provider};

\draw[arrow] (u1) -- (si.north);
\draw[arrow] (u2) -- (si.north);
\draw[arrow] (u3) -- (si.north);
\draw[arrow] (a1) -- (si.south);
\draw[arrow] (a2) -- (si.south);
\draw[arrow] (a3) -- (si.south);

\end{tikzpicture}
\caption{Structure service, service-provider-interface, service-provider} 
\label{fig:spi}
\end{figure}

%--------1---------2---------3---------4---------5---------6---------7---------8
If the \verb!maven-plugin! finds the library with the \verb!java-addon! 
implementation running it will generate the sources in java, but if it finds 
the \verb!scala-addon! implementation it will generate the scala sources.

%--------1---------2---------3---------4---------5---------6---------7---------8
The documentation is divided into three parts. In the first, \ref{vol:spi}, a 
detailed description of the classes is given defined in the 
\textsl{service provider interface}, this part is useful for those wishing to 
develop a \textit{custom service} or a \textit{custom provider}. 
If you are only interested in how to generate code starting from config files 
it can be skipped.

%--------1---------2---------3---------4---------5---------6---------7---------8
In the second part, \ref{vol:srv}, a description of two plugins used to generate 
the code is given. In particular how to define the layouts with the 
configuration files and how to activate the plugin.

%--------1---------2---------3---------4---------5---------6---------7---------8
In the third part, \ref{vol:sp}, a description of the \textsl{service provider} 
that generates the java source showing also some additional features of 
generated classes beyond simple setters and getters.

%\input{cover.tex}

\clearpage

\tableofcontents

\clearpage

\part{Service Provider Interface}\label{vol:spi}

%  ___       _             __                
% |_ _|_ __ | |_ ___ _ __ / _| __ _  ___ ___ 
%  | || '_ \| __/ _ \ '__| |_ / _` |/ __/ _ \
%  | || | | | ||  __/ |  |  _| (_| | (_|  __/
% |___|_| |_|\__\___|_|  |_|  \__,_|\___\___|
%                                           

\chapter{Service Provider Interface}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!recfm-addon-api! artifact provides a series of interfaces, some enums 
and java-beans to allow the client module to define the paths. 
The code is compiled so that it is compatible with java 5, but it provides the 
\verb!module-info! to be usable properly even with java 9 and above.

\section{CodeProvider}\index{CodeProvider}
%--------1---------2---------3---------4---------5---------6---------7---------8
The starting point is the \textsl{CodeProvider} interface, retrieved from the 
\textsl{ServiceLoader}, see lst.~\ref{lst:CodeProvider}, this interface
provides the instance of the \textsl{CodeFactory} interface.

\begin{elisting}[!htb]
\begin{javacode}
      ServiceLoader<CodeProvider> loader = ServiceLoader.load(CodeProvider.class);
      CodeProvider codeProvider = loader.iterator().next();
\end{javacode}
\vspace*{-1cm}
\begin{javacode}
public interface CodeProvider {
     |\hyperref[lst:CodeFactory]{CodeFactory}| getInstance();
}
\end{javacode}
\caption{CodeProvider interface and retrieving the CodeProvider from the ServiceLoader}
\label{lst:CodeProvider}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8


\section{CodeFactory}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{CodeFactory} interface, see lst.~\ref{lst:CodeFactory}, provides 
methods for defining all elements of the structure.

\begin{elisting}[!htb]
\begin{javacode}
public interface CodeFactory {
    |\hyperref[lst:ClassModel]{ClassModel}| newClassModel();
    |\hyperref[lst:TraitModel]{TraitModel}| newTraitModel();

    |\hyperref[lst:AbcModel]{AbcModel}| newAbcModel();
    |\hyperref[lst:NumModel]{NumModel}| newNumModel();
    |\hyperref[lst:NuxModel]{NuxModel}| newNuxModel();
    |\hyperref[lst:CusModel]{CusModel}| newCusModel();
    |\hyperref[lst:DomModel]{DomModel}| newDomModel();
    |\hyperref[lst:FilModel]{FilModel}| newFilModel();
    |\hyperref[lst:ValModel]{ValModel}| newValModel();
    |\hyperref[lst:GrpModel]{GrpModel}| newGrpModel();
    |\hyperref[lst:OccModel]{OccModel}| newOccModel();
    |\hyperref[lst:EmbModel]{EmbModel}| newEmbModel();
    |\hyperref[lst:GrpTraitModel]{GrpTraitModel}| newGrpTraitModel();
    |\hyperref[lst:OccTraitModel]{OccTraitModel}| newOccTraitModel();
}
\end{javacode}
\caption{CodeFactory interface}
\label{lst:CodeFactory}\index{CodeFactory}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8

\section{Classes / Interfaces}
%--------1---------2---------3---------4---------5---------6---------7---------8
The first method of the \textsl{CodeFactory} interface supplies the definition 
for a class, see lst.~\ref{lst:ClassModel}, and the second interface method 
\textsl{CodeFactory} provides the definition for an interface, see 
lst.~\ref{lst:TraitModel}.

\begin{elisting}[!htb]
\begin{javacode}
public interface ClassModel {
    void setName(String name);
    void setLength(int length);
    void setOnOverflow(|\hyperref[lst:LoadOverflowAction]{LoadOverflowAction}| onOverflow);
    void setOnUnderflow(|\hyperref[lst:LoadUnderflowAction]{LoadUnderflowAction}| onUnderflow);
    void setDoc(Boolean doc);
    void setFields(List<FieldModel> fields);

    void create(String namespace, |\hyperref[lst:GenerateArgs]{GenerateArgs}| ga, |\hyperref[lst:FieldDefault]{FieldDefault}| defaults);
}
\end{javacode}
\caption{ClassModel interface}
\label{lst:ClassModel}\index{ClassModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Both definitions require the name of the structure, its length, whether to 
generate or not the automatic documentation for the class, the list of fields 
that compose it and make available a method for generating the source code.

\begin{elisting}[!htb]
\begin{javacode}
public interface TraitModel {
    void setName(String name);
    void setLength(int length);
    void setDoc(Boolean doc);
    void setFields(List<FieldModel> fields);

    void create(String namespace, |\hyperref[lst:GenerateArgs]{GenerateArgs}| ga, |\hyperref[lst:FieldDefault]{FieldDefault}| defaults);
}
\end{javacode}
\caption{TraitModel interface}
\label{lst:TraitModel}\index{TraitModel}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The class definition also takes two additional parameters to indicate how to 
behave if the size of the data provided was higher or lower than expected.

%--------1---------2---------3---------4---------5---------6---------7---------8
Before seeing the detail of the definition of the various fields, let's see the 
content of the other two parameters required for source code generation.

\subsection{Global Arguments --- GenerateArgs}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{GenerateArgs} class, see lst.~\ref{lst:GenerateArgs}, allows you to 
define some general parameters, common to all classes generate. 
%--------1---------2---------3---------4---------5---------6---------7---------8
The \texttt{sourceDirectory} parameter indicates the root source directory where
to generate the sources, the three subsequent parameters identify the program 
(or plugin) that provided the definition of the layout, these parameters are 
shown as a comment at the beginning of the generated files.

\begin{elisting}[!htb]
\begin{javacode}
@Builder
public class GenerateArgs {
    @NonNull public final String sourceDirectory;
    public final String group;
    public final String artifact;
    public final String version;
}
\end{javacode}
\caption{GenerateArgs class}
\label{lst:GenerateArgs}\index{GenerateArgs}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8

\subsection{Field Defaults --- FieldDefault}
%--------1---------2---------3---------4---------5---------6---------7---------8
In the definition of classes and fields, some parameters available in their 
definition change necessarily (the name of the field), others are almost always 
the same for the same type of field (such as are valid characters in an 
alphanumeric field).
To simplify the definition of the classes, and related fields, it is possible to
omit the ``slightly variable'' parameters in the definition, however it is 
necessary to indicate which value to use for these parameters when they are 
omitted. 
The \textsl{FieldDefault} class, lst.~\ref{lst:FieldDefault}, provides some 
classes dedicated to set the default of the ``slightly variable'' parameters.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class FieldDefault {
    private |\hyperref[lst:ClsDefault]{ClsDefault}| cls = new ClsDefault();
    private |\hyperref[lst:AbcDefault]{AbcDefault}| abc = new AbcDefault();
    private |\hyperref[lst:NumDefault]{NumDefault}| num = new NumDefault();
    private |\hyperref[lst:NuxDefault]{NuxDefault}| nux = new NuxDefault();
    private |\hyperref[lst:FilDefault]{FilDefault}| fil = new FilDefault();
    private |\hyperref[lst:CusDefault]{CusDefault}| cus = new CusDefault();
}
\end{javacode}
\caption{FieldDefault class}
\label{lst:FieldDefault}\index{FieldDefault}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The first default concerns the default behavior of the class when it is created 
starting from a structure (string), and this has a dimension different from the 
expected one; if the length of the supplied structure is greater than the 
expected one, it is possible to throw an exception and ignore the excess 
content, if the length of the supplied structure is less than the expected one, 
it is possible to throw an exception or complete the missing part with the 
default values of the missing part.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public static class ClsDefault {
    private |\hyperref[lst:LoadOverflowAction]{LoadOverflowAction}| onOverflow = LoadOverflowAction.Trunc;   // enum {Error, Trunc}
    private |\hyperref[lst:LoadUnderflowAction]{LoadUnderflowAction}| onUnderflow = LoadUnderflowAction.Pad;  // enum {Error, Pad}
    private boolean doc = true;
}
\end{javacode}
\caption{ClsDefault class}\index{ClsDefault}
\label{lst:ClsDefault}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8

%--------1---------2---------3---------4---------5---------6---------7---------8
The other defaults allow you to set the default values of some parameters for 
five types of fields. Not having shown the details of the definition of the 
various types of field, it is not appropriate to introduce the content of the 
default classes at this point, they will be shown together with the 
corresponding field.

\chapter{Definition of single fields}
%--------1---------2---------3---------4---------5---------6---------7---------8
In the definition of the class, and of the interface, the list of fields is set 
as \verb!List<FieldModel>!, but the \verb!FieldModel! interface is an empty box, 
it is only used to connect all the field definitions to it.
In general all fields have an initial position (offset) and a dimension 
(length); many fields are referable by a name, but not all are necessarily 
named; when the fields have a name they can be primary or over-define (override) 
primary fields, in the initialization phase of the fields of a class only 
primary field definitions are considered.

%--------1---------2---------3---------4---------5---------6---------7---------8
In the field definitions, the initial position of the field (offset) is set as 
an \texttt{Integer}, ie in general it is not mandatory to set it, it can be 
calculated automatically by the \textsl{Service Provider}.

\section{Alphanumeric field}
%--------1---------2---------3---------4---------5---------6---------7---------8
An alphanumeric field has 4 basic parameters: \verb!offset!, \verb!length!, 
\verb!name! and \verb!override!.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!onOverflow! and \verb!onUnderflow! parameters indicate how the setter 
should behave when a value with a size greater or less than that foreseen for 
that field is supplied. 
The \hypertarget{abc:ovf}{\texttt{onOverflow}} parameter can assume the values 
\verb!Error! and \verb!Trunc!, in the first case the code is expected to 
generate an exception, in the second case the value is found (on the right) 
ignoring the characters in excess of the expected size. 
The \hypertarget{abc:unf}{\texttt{onUnderflow}} parameter can assume the values 
\verb!Error! and \verb!Pad!, in the first case the code is expected to generate 
an exception, in the second case spaces are added (on the right) to reach the 
expected size.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \hypertarget{abc:chk}{\texttt{check}} parameter allows you to specify checks 
to restrict the set of characters allowed for the value. This control is 
activated during the validation of the data string, calling the setters and 
getters. 
Possible values are \verb!None!, \verb!Ascii!, \verb!Latin1!, \verb!Valid!, in 
the first case no check is done, in the second case only ASCII characters are 
accepted, in the third case only ISO-8859-1\footnote{%
more precisely the unicode characters from \texttt{\textbackslash u0020} to 
\texttt{\textbackslash u007e} and from \texttt{\textbackslash u00a0} to 
\texttt{\textbackslash u00ff}
} characters are accepted, and in the last case valid UTF-8 characters are 
accepted.

\begin{elisting}[!htb]
\begin{javacode}
public interface AbcModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);

    void setOverride(boolean override);

    void setOnOverflow(|\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow);
    void setOnUnderflow(|\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow);
    void setCheck(|\hyperref[lst:CheckAbc]{CheckAbc}| check);
    void setNormalize(|\hyperref[lst:NormalizeAbcMode]{NormalizeAbcMode}| normalize);
    void setCheckGetter(Boolean checkGetter);
    void setCheckSetter(Boolean checkSetter);
}
\end{javacode}
\caption{interface AbcModel (alphanumeric field)}
\label{lst:AbcModel}\index{AbcModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The \hypertarget{abc:nrm}{\texttt{normalize}} parameter allows you to indicate 
how to normalize the value of the field in the getter phase. 
The \verb!normalize! parameter can take on 3 values \verb!None!, \verb!Trim! 
and \verb!Trim1!. The first value indicates not to perform any modification of 
the data, the second value indicates to remove all spaces on the right until a 
character other than space is found, if the value is composed only of spaces an 
empty string is produced, the last value, similarly to the previous value, 
removes the spaces on the right until a character other than a space is found, 
but if the value is composed only of spaces, it returns a string composed of a 
space.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \hypertarget{abc:get}{\texttt{checkGetter}} parameter indicates whether or 
not to activate the control indicated with the \verb!check! parameter when the 
getter is called; if the data-string is previously validated, this check can be 
deactivated. 
The \hypertarget{abc:set}{\texttt{checkSetter}} parameter indicates whether or 
not to activate the control indicated with the \verb!check! parameter when 
called the setter.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class AbcDefault {
    private |\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow = OverflowAction.Trunc;
    private |\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow = UnderflowAction.Pad;
    private |\hyperref[lst:CheckAbc]{CheckAbc}| check = CheckAbc.Ascii;
    private |\hyperref[lst:NormalizeAbcMode]{NormalizeAbcMode}| normalize = NormalizeAbcMode.None;
    private boolean checkGetter = true;
    private boolean checkSetter = true;
}
\end{javacode}
\caption{class AbcDefault (default campo alfanumerico)}
\label{lst:AbcDefault}\index{AbcDefault}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{AbcDefault} class, see lst.~\ref{lst:AbcDefault}, set the default 
values for the parameters \verb!onOverflow!, \verb!onUnderflow!, \verb!check!, 
\verb!normalize!, \verb!checkGetter!, \verb!checkSetter!, in case they are not 
set by the client.

\section{Numeric field}\label{sec:spi.num}
%--------1---------2---------3---------4---------5---------6---------7---------8
Even a numeric field has 4 basic parameters: \verb!offset!, \verb!length!,
\verb!name! and \verb!override!.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!access! parameter indicates how to generate the setters and getters. 
In the data-string the numeric field has a representation in string format, in 
the generated code it is possible to choose whether the setters and getters 
manage the value as a string (with numeric characters) or to convert 
the data-string fragment, corresponding to the field, into a native numeric 
representation (\verb!byte!, \verb!short!, \verb!int!, \verb!long!) or 
handle both.
%
The \verb!access! parameter can take on the values \verb!String!, \verb!Number! 
and \verb!Both!. In the first case, setters and getters are generated that 
handle the value as a (numeric) string, in the second case as a native numeric, 
and in the last case both are generated (it will be indicated by the provider 
how to distinguish the string getter from the numeric one). 
If an access is used that provides string type setter/getter, it is checked in 
the setter phase that the supplied string is numeric, and in the getter phase 
that the returned string is numeric.

\begin{elisting}[!htb]
\begin{javacode}
public interface NumModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);

    void setOverride(boolean override);

    void setAccess(|\hyperref[lst:AccesMode]{AccesMode}| access);
    void setWordWidth(|\hyperref[lst:WordWidth]{WordWidth}| width);
    void setOnOverflow(|\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow);
    void setOnUnderflow(|\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow);
    void setNormalize(|\hyperref[lst:NormalizeNumMode]{NormalizeNumMode}| normalize);
}
\end{javacode}
\caption{NumModel interface (numeric field)}
\label{lst:NumModel}\index{NumModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!wordWidth! parameter makes sense only if an access mode has been 
chosen that generates numeric setters/getters, it basically indicates the 
minimum size to be used in numeric representations. 
The \verb!wordWidth! parameter can assume the values \verb!Byte!, \verb!Short!, 
\verb!Int! and \verb!Long!, the values correspond to the use of the 
corresponding native types. 
For example, if a numeric field is represented by a 4-character string, it can 
be converted into numeric format as \verb!short!, if the \verb!wordWidth! 
parameter is set to \verb!Int!, \verb!int! type setters/getters are generated; 
if the parameter value had been \verb!Byte! or \verb!Short!, \verb!short!-type 
setters/getters would have been generated.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!onOverflow! and \verb!onUnderflow! parameters indicate how the setter 
should behave when a value larger or smaller than that expected for that field 
is supplied. 
The \verb!onOverflow! parameter can assume the values \verb!Error! and 
\verb!Trunc!, in the first case the code is expected to generate an exception, 
in the second case the value is truncated (on the left) ignoring the digits in 
excess of the expected size. 
The \verb!onUnderflow! parameter can assume the values \verb!Error! and 
\verb!Pad!, in the first case the code is expected to generate an exception, in 
the second case zeros are added (on the left) to reach the expected size.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!normalize! parameter makes sense only if an access mode has been 
chosen that generates string setters/getters, it allows you to indicate how to 
normalize the value of the field in the getter phase. 
The \verb!normalize! parameter can take on 2 values \verb!None! and \verb!Trim!. 
The first value indicates not to perform any modification of the data, the 
other indicates to remove all the zeros on the left until a digit other than 
zero is found, if the value is composed only of zeros a string composed of a 
zero is produced .

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class NumDefault {
    private |\hyperref[lst:AccesMode]{AccesMode}| access = AccesMode.String;
    private |\hyperref[lst:WordWidth]{WordWidth}| wordWidth = WordWidth.Int;
    private |\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow = OverflowAction.Trunc;
    private |\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow = UnderflowAction.Pad;
    private |\hyperref[lst:NormalizeNumMode]{NormalizeNumMode}| normalize = NormalizeNumMode.None;
}
\end{javacode}
\caption{class NumDefault (default numeric field)}
\label{lst:NumDefault}\index{NumDefault}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{NumDefault} class, see lst.~\ref{lst:NumDefault}, sets the default 
values for the \verb!access!, \verb!wordWidth!, \verb!onOverflow!, 
\texttt{onUnder\-flow} and \verb!normalize! parameters if they are not set by the 
client.

\section{Custom field (alphanumeric)}
%--------1---------2---------3---------4---------5---------6---------7---------8
Even a custom field has the 4 basic parameters: \verb!offset!, \verb!length!,
\verb!name! and \verb!override!.

%--------1---------2---------3---------4---------5---------6---------7---------8
A custom field is a generalization of an alphanumeric field, and can be 
configured to emulate a numeric or nullable numeric field. 
The first sensitive parameter to consider is \verb!align!, the parameter 
indicates how the \texttt{onUnderflow = Pad} field must be aligned. 
The parameter can assume 2 values \verb!LFT! and \verb!RGT!, the first value 
indicates that the field must be aligned to the left, the second value must be 
aligned to the right.
The value of this parameter not only affects the \verb!onUnderflow! parameter 
(indicating from which direction the padding characters must be added), but 
also on \verb!onOverflow! (indicating from which direction the excess characters 
must be removed) and \verb!normalize! (indicating from which direction the 
padding characters be removed).

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!padChar! parameter indicates the padding character to add (in case of 
\texttt{onUnderflow = Pad}) or remove (in case of \texttt{normalize = Trim}). 

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!initChar! parameter indicates the character to use to initialize the 
field.

\begin{elisting}[!htb]
\begin{javacode}
public interface CusModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);
    
    void setOverride(boolean override);
    
    void setAlign(|\hyperref[lst:AlignMode]{AlignMode}| align);
    void setPadChar(Character padChar);
    void setInitChar(Character initChar);
    void setCheck(|\hyperref[lst:CheckCus]{CheckCus}| check);
    void setRegex(String regex);
    void setOnOverflow(|\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow);
    void setOnUnderflow(|\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow);
    void setNormalize(|\hyperref[lst:NormalizeAbcMode]{NormalizeAbcMode}| normalize);
    void setCheckGetter(Boolean checkGetter);
    void setCheckSetter(Boolean checkSetter);
}
\end{javacode}
\caption{CusModel interface (custom field)}
\label{lst:CusModel}\index{CusModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
For the \verb!check! parameter the same considerations apply as for the 
corresponding parameter in the \hyperlink{abc:chk}{alphanumeric case}. 
In this case the possible values are \verb!None!, \verb!Ascii!, \verb!Latin1!, 
\verb!Valid!, \verb!Digit! and \verb!DigitOrBlank!. 
The first four values are identical to the alphanumeric case, the \verb!Digit! 
value limits the accepted characters to numeric ones (from 0 to 9), as for a 
numeric field; the \verb!DigitOrBlank! value requires that the characters be 
numeric or all spaces, such as for a nullable numeric field.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!regex! parameter can be valued with a regular expression that must be 
satisfied by the value of the field. If this parameter is present, the 
\verb!check! parameter is ignored.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class CusDefault {
    private |\hyperref[lst:AlignMode]{AlignMode}| align = AlignMode.LFT;
    private char padChar = ' ';
    private char initChar = ' ';
    private |\hyperref[lst:CheckCus]{CheckCus}| check = CheckCus.Ascii;
    private |\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow = OverflowAction.Trunc;
    private |\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow = UnderflowAction.Pad;
    private |\hyperref[lst:NormalizeAbcMode]{NormalizeAbcMode}| normalize = NormalizeAbcMode.None;
    private boolean checkGetter = true;
    private boolean checkSetter = true;
}
\end{javacode}
\caption{class CusDefault (custom field default)}
\label{lst:CusDefault}\index{CusDefault}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
For the parameters 
\hyperlink{abc:unf}{\texttt{onUnderflow}}, 
\hyperlink{abc:nrm}{\texttt{normalize}},
\hyperlink{abc:get}{\texttt{checkGetter}},
\hyperlink{abc:get}{\texttt{checkSetter}}
the same considerations apply as for the corresponding fields in the 
alphanumeric case. Be careful because the action of the \verb!onOverflow!, 
\verb!onUnderflow! and \verb!normalize! parameters also depends on the value of 
the \verb!align! and \verb!initChar! parameters.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{CusDefault} class, see lst.~\ref{lst:CusDefault}, sets the default 
values for the \verb!align!, \verb!padChar!, \verb!initChar!, 
\verb!check!, \texttt{onOver\-flow}, \verb!onUnderflow!, \verb!normalize!, 
\verb!checkGetter! and \verb!checkSetter! parameters if they are not set by the 
client.

\section{Nullable numeric field}
%--------1---------2---------3---------4---------5---------6---------7---------8
A nullable numeric field is an extension of an ordinary numeric field. 
The difference is that the space value (all space characters) is allowed in the 
data-string, this value corresponds to the \verb!null! value in the data-class 
field.

\begin{elisting}[!htb]
\begin{javacode}
public interface NuxModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);

    void setOverride(boolean override);

    void setAccess(|\hyperref[lst:AccesMode]{AccesMode}| access);
    void setWordWidth(|\hyperref[lst:WordWidth]{WordWidth}| width);
    void setOnOverflow(|\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow);
    void setOnUnderflow(|\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow);
    void setNormalize(|\hyperref[lst:NormalizeNumMode]{NormalizeNumMode}| normalize);
    void setInitialize(|\hyperref[lst:InitializeNuxMode]{InitializeNuxMode}| initialize);
}
\end{javacode}
\caption{NuxModel interface (nullable numeric field)}
\label{lst:NuxModel}\index{NuxModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
As can be seen from the definition, lst.~\ref{lst:NuxModel} there are the same 
parameters of a numeric field (lst.~\ref{lst:NumModel}), with the same meanings, 
plus one: the \verb!initialize! parameter. 
This parameter indicates how to initialize the field when the class is created 
with an empty constructor, with the value spaces (i.e. \verb!null!) or zero.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class NuxDefault {
    private |\hyperref[lst:AccesMode]{AccesMode}| access = AccesMode.String;
    private |\hyperref[lst:WordWidth]{WordWidth}| wordWidth = WordWidth.Int;
    private |\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow = OverflowAction.Trunc;
    private |\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow = UnderflowAction.Pad;
    private |\hyperref[lst:NormalizeNumMode]{NormalizeNumMode}| normalize = NormalizeNumMode.None;
    private |\hyperref[lst:InitializeNuxMode]{InitializeNuxMode}| initialize = InitializeNuxMode.Spaces;
}
\end{javacode}
\caption{NuxDefault (default nullable numeric field)}
\label{lst:NuxDefault}\index{NuxDefault}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
To manage the default at a general level for this type of field, a dedicated 
default class is used, which is the copy of the corresponding one for the 
ordinary numeric case, plus the initialization default.

\section{Domain field}
%--------1---------2---------3---------4---------5---------6---------7---------8
A domain-type field is an alphanumeric field that can only assume predefined 
constant values. 
The domain type field, lst.~\ref{lst:DomModel}, has the 4 basic parameters: 
\verb!offset!, \verb!length!, \verb!name! and \verb!override!, plus the 
\verb!items! parameter which will have to provide the list of allowed constant 
values.

\begin{elisting}[!htb]
\begin{javacode}
public interface DomModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);
    
    void setOverride(boolean override);
    
    void setItems(String[] items);
}
\end{javacode}
\caption{DomModel interface (domain field)}
\label{lst:DomModel}\index{DomModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
For this type of field, no global default makes sense as seen for alphanumeric 
and numeric fields. The allowed values are those supplied in the \verb!items! 
parameter, any other value will cause an exception.

\section{Filler field}
%--------1---------2---------3---------4---------5---------6---------7---------8
A field of type \textsl{Filler} is not a real field, has no associated name, 
does not generate any setter or getter in the data-class, and no control 
methods. It is a way to indicate that in the data-string there is an area to 
which no value is associated, or that we are not interested in that area of 
the data-string.

\begin{elisting}[!htb]
\begin{javacode}
public interface FilModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    
    void setFill(Character fill);
}
\end{javacode}
\caption{FilModel interface (filler field)}
\label{lst:FilModel}\index{FilModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The filler field has only the 2 basic parameters: \verb!offset! and 
\verb!length!. It then has the \verb!fill! parameter to indicate with which 
character to value the field when the data-class is created with the empty 
constructor.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class FilDefault {
    private char fill = 0;
}
\end{javacode}
\caption{class FilDefault (default filler field)}
\label{lst:FilDefault}\index{FilDefault}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The filler field has a default class dedicated to indicate the filler character 
at a general level.

\section{Field Constant value}
%--------1---------2---------3---------4---------5---------6---------7---------8
A field of type \textsl{Constant} is similar to a filler field. As for the 
filler field, setters and getters are not generated in the data-class, but in 
the validation of the data-string it is verified that the area corresponding to 
the field has the indicated constant value.

\begin{elisting}[!htb]
\begin{javacode}
public interface ValModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    
    void setValue(String value);
}
\end{javacode}
\caption{ValModel interface (constant range)}
\label{lst:ValModel}\index{ValModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Even the constant field has only the 2 basic parameters: \verb!offset! and 
\verb!length!. It then has the \verb!value! parameter to indicate the expected 
constant value. The supplied value is used to set the value when the data-class 
is instantiated with the empty constructor.


\chapter{Definition of a group of fields}
%--------1---------2---------3---------4---------5---------6---------7---------8
In some cases it may be useful to group some fields within a container element. 
This allows you to have within the definition of the string-data structure two 
fields with the same name within different container elements.

\section{Field group}
%--------1---------2---------3---------4---------5---------6---------7---------8
A field of type \textsl{Group} is not a real field, it is actually a container 
of other fields.

\begin{elisting}[!htb]
\begin{javacode}
public interface GrpModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);
    
    void setOverride(boolean override);
    
    void setFields(List<FieldModel> fields);
}
\end{javacode}
\caption{interfaccia GrpModel (campo gruppo)}
\label{lst:GrpModel}\index{GrpModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
A group field has 4 basic parameters: \verb!offset!, \verb!length!, \verb!name! 
and \verb!override!. 
In addition to this, it provides the \verb!fields! parameter to provide the list 
of child fields. 
The string-data area selected by \verb!offset! and \verb!length! will need to be 
completely defined by the child fields. 
It is possible for a child field to use the same name as a field defined at the 
same level as the parent field.

\section{Repeating field group}
%--------1---------2---------3---------4---------5---------6---------7---------8
A field of type \textsl{Repeating Group} is similar to a group field, except 
that there are $n$ occurrences of the group. 
In addition to the parameters used by the group field, there is the \verb!times! 
parameter, which indicates the number of times the group is repeated.

\begin{elisting}[!htb]
\begin{javacode}
public interface OccModel extends  FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);
    
    void setOverride(boolean override);
    
    void setFields(List<FieldModel> fields);
    void setTimes(int times);
}
\end{javacode}
\caption{OccModel interface (repeating group field)}
\label{lst:OccModel}\index{OccModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
In this case the area of the data-string defined by \verb!offset! and 
\verb!length! is that of the first occurrence of the group. 
The dimension actually used is \verb!length! $\times$ \verb!times!.

\section{Fields embedded via interface}
%--------1---------2---------3---------4---------5---------6---------7---------8
An interface (lst.~\ref{lst:TraitModel}) can be defined in the same way as a 
class (lst.~\ref{lst:ClassModel}). 
The \textsl{Embedded} field is not a real field, it doesn't have a name. 
Used to indicate that a certain area of the data-string must be interpreted with 
the fields defined by the indicated interface.

\begin{elisting}[!htb]
\begin{javacode}
public interface EmbModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    
    void setSource(|\hyperref[lst:TraitModel]{TraitModel}| source);
}
\end{javacode}
\caption{EmbModel interface (embedded field)}
\label{lst:EmbModel}\index{EmbModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The embedded field has only the 2 basic parameters: \verb!offset! and 
\verb!length!. 
It then has the \verb!source! parameter to indicate which interface to use to 
define the fields. The interface must have the same size (\verb!length!) of the 
embedded field, the initial position of the interface will be translated to 
adapt it to the value indicated by the embedded field. 
The generated class will obviously implement the indicated interface.

\section{Field group defined via interface} 
%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{Group/Interface} field is similar to the embedded field. 
In this case the fields defined by the interface are not incorporated at the 
current level, but a group containing them is defined.

\begin{elisting}[!htb]
\begin{javacode}
public interface GrpTraitModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);
    
    void setOverride(boolean override);
    
    void setTypedef(|\hyperref[lst:TraitModel]{TraitModel}| typedef);
}
\end{javacode}
\caption{GrpTraitModel interface (group/interface field)}
\label{lst:GrpTraitModel}\index{GrpTraitModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
A group/interface field has 4 basic parameters: \verb!offset!, \verb!length!, 
\verb!name! and \verb!override!. It then has the \verb!typedef! parameter to 
indicate which interface to use to define the fields of the group. 
The interface must have the same size (\verb!length!) of the group/interface 
field, the initial position of the interface will be translated to adapt it to 
the value indicated by the group/interface field. 
In this case it is the group that implements the indicated interface.


\section{Repeating field group defined via interface}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{Repeating Group/Interface} field is similar to the group/interface 
field, except that there are $n$ occurrences of the group. 
In addition to the parameters used by the group/interface field, there is the 
\verb!times! parameter, which indicates the number of times the group is 
repeated.

\begin{elisting}[!htb]
\begin{javacode}
public interface OccTraitModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);
    
    void setOverride(boolean override);
    
    void setTypedef(|\hyperref[lst:TraitModel]{TraitModel}| typedef);
    void setTimes(int times);
}
\end{javacode}
\caption{interface OccTraitModel (repeating group/interface field)}
\label{lst:OccTraitModel}\index{OccTraitModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
As in the case of the repeated group, the area of the data-string defined by 
\verb!offset! and \verb!length! is that of the first occurrence of the group. 
The dimension actually used is \verb!length! $\times$ \verb!times!.

\vspace*{5cm}

\chapter{Used enums}
%--------1---------2---------3---------4---------5---------6---------7---------8
Many of the configuration classes or interfaces have fields with values that are 
limited to some value expressed by \texttt{enum}. 
Let's see them one by one.

\begin{elisting}
\begin{javacode}
public enum LoadOverflowAction { Error, Trunc }
\end{javacode}
\caption{enum LoadOverflowAction}\label{lst:LoadOverflowAction}\index{LoadOverflowAction}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \hyperref[lst:LoadOverflowAction]{\texttt{LoadOverflowAction}} enum is used 
by the \hyperref[lst:ClassModel]{\texttt{ClassModel}} class to indicate how to 
behave when the class is deserialized and the data-string is larger than 
expected by the data-class.

\begin{elisting}
\begin{javacode}
public enum LoadUnderflowAction { Error, Pad }
\end{javacode}
\caption{enum LoadUnderflowAction}\label{lst:LoadUnderflowAction}\index{LoadUnderflowAction}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \hyperref[lst:LoadUnderflowAction]{\texttt{LoadUnderflowAction}} enum is 
used by the \hyperref[lst:ClassModel]{\texttt{ClassModel}} class to indicate how 
to behave when the class is deserialized and the data-string has a smaller size 
than expected by the data-class.

\begin{elisting}
\begin{javacode}
public enum CheckAbc { None, Ascii, Latin1, Valid }
\end{javacode}
\caption{enum CheckAbc}\label{lst:CheckAbc}\index{CheckAbc}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \hyperref[lst:CheckAbc]{\texttt{CheckAbc}} enum is used by the 
\hyperref[lst:AbcModel]{\texttt{AbcModel}} class to indicate which characters 
are considered valid.

\begin{elisting}
\begin{javacode}
public enum OverflowAction { Error, Trunc }
\end{javacode}
\caption{enum OverflowAction}\label{lst:OverflowAction}\index{OverflowAction}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \hyperref[lst:OverflowAction]{\texttt{OverflowAction}} enum is used by the 
class to manage numeric and alphanumeric fields 
(\hyperref[lst:AbcModel]{\texttt{AbcModel}},
\hyperref[lst:NumModel]{\texttt{NumModel}},
\hyperref[lst:CusModel]{\texttt{CusModel}},
\hyperref[lst:NuxModel]{\texttt{NuxModel}}), to indicate how to behave when the 
setter proposes a value that has a size greater than the one expected for that 
field.

\begin{elisting}
\begin{javacode}
public enum UnderflowAction { Error, Pad }
\end{javacode}
\caption{enum UnderflowAction}\label{lst:UnderflowAction}\index{UnderflowAction}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \hyperref[lst:UnderflowAction]{\texttt{UnderflowAction}} enum is used by the 
class to manage numeric and alphanumeric fields 
(\hyperref[lst:AbcModel]{\texttt{AbcModel}},
\hyperref[lst:NumModel]{\texttt{NumModel}},
\hyperref[lst:CusModel]{\texttt{CusModel}},
\hyperref[lst:NuxModel]{\texttt{NuxModel}}), to indicate how to behave when the 
setter proposes a value that has a size smaller than the one expected for that 
field.

\begin{elisting}
\begin{javacode}
public enum NormalizeAbcMode { None, Trim, Trim1 }
\end{javacode}
\caption{enum NormalizeAbcMode}\label{lst:NormalizeAbcMode}\index{NormalizeAbcMode}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \hyperref[lst:NormalizeAbcMode]{\texttt{NormalizeAbcMode}} enum is used by 
the class to manage alphanumeric fields 
(\hyperref[lst:AbcModel]{\texttt{AbcModel}},
\hyperref[lst:CusModel]{\texttt{CusModel}}), to indicate how to normalize the 
value returned by the getter.

\begin{elisting}
\begin{javacode}
public enum NormalizeNumMode { None, Trim }
\end{javacode}
\caption{enum NormalizeNumMode}\label{lst:NormalizeNumMode}\index{NormalizeNumMode}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \hyperref[lst:NormalizeNumMode]{\texttt{NormalizeNumMode}} enum is used by 
the class to manage numeric fields (\hyperref[lst:NumModel]{\texttt{NumModel}},
\hyperref[lst:NuxModel]{\texttt{NuxModel}}), to indicate how to normalize the 
value returned by the getter.

\begin{elisting}
\begin{javacode}
public enum WordWidth { Byte, Short, Int, Long }
\end{javacode}
\caption{enum WordWidth}\label{lst:WordWidth}\index{WordWidth}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \hyperref[lst:WordWidth]{\texttt{WordWidth}} enum is used by the class to 
handle numeric fields (\hyperref[lst:NumModel]{\texttt{NumModel}},
\hyperref[lst:NuxModel]{\texttt{NuxModel}}), to indicate the primitive numeric 
data type of minimum size to use when creating numeric setters and getters.

\begin{elisting}
\begin{javacode}
public enum AccesMode { String, Number, Both }
\end{javacode}
\caption{enum AccesMode}\label{lst:AccesMode}\index{AccesMode}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \hyperref[lst:AccesMode]{\texttt{AccesMode}} enum is used by the class to 
handle numeric fields (\hyperref[lst:NumModel]{\texttt{NumModel}},
\hyperref[lst:NuxModel]{\texttt{NuxModel}}), to indicate whether to create 
alphanumeric, numeric, or both setters and getters.

\begin{elisting}
\begin{javacode}
public enum InitializeNuxMode { Spaces, Zeroes }
\end{javacode}
\caption{enum InitializeNuxMode}\label{lst:InitializeNuxMode}\index{InitializeNuxMode}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \hyperref[lst:InitializeNuxMode]{\texttt{InitializeNuxMode}} enum is used 
by the \hyperref[lst:NuxModel]{\texttt{NuxModel}} class, to indicate how to 
initialize the field when the data-class is created with the constructor with 
no arguments.

\begin{elisting}
\begin{javacode}
public enum CheckCus { None, Ascii, Latin1, Valid, Digit, DigitOrBlank }
\end{javacode}
\caption{enum CheckCus}\label{lst:CheckCus}\index{CheckCus}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \hyperref[lst:CheckCus]{\texttt{CheckCus}} enum is used by the 
\hyperref[lst:CusModel]{\texttt{CusModel}} class to indicate which characters 
are considered valid.

\begin{elisting}
\begin{javacode}
public enum AlignMode { LFT, RGT }
\end{javacode}
\caption{enum AlignMode}\label{lst:AlignMode}\index{AlignMode}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \hyperref[lst:CheckCus]{\texttt{CheckCus}} enum is used by the 
\hyperref[lst:CusModel]{\texttt{CusModel}} class to indicate how to align the 
field.

\vfill

\part{Service}\label{vol:srv}

%  ____                  _          
% / ___|  ___ _ ____   _(_) ___ ___ 
% \___ \ / _ \ '__\ \ / / |/ __/ _ \
%  ___) |  __/ |   \ V /| | (_|  __/
% |____/ \___|_|    \_/ |_|\___\___|
%                                  

\chapter*{Service}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{Service Provider Interface} simply fixes the general structure, but 
contains only interfaces and java-beans.
The \textsl{Service} is the application that allows the user to provide the 
input required by the \textsl{Service Provider Interface}. 
To produce the output, the \textsl{Service} will use the \textsl{ServiceLoader} 
to search the classpath for a \textsl{Service Provider} that implements the 
\textsl{Service Provider Interface}, and the \textsl{Service Provider} will 
generate the output from the input.

%--------1---------2---------3---------4---------5---------6---------7---------8
The heart of the \textsl{Service Provider Interface}, \verb!recfm-addon-api!, is 
the \textsl{CodeProvider} interface. The implementation of the interface is 
searched with the ServiceLoader mechanism, lst.~\ref{lst:getCodeProvider}.

\begin{elisting}[!htb]
\begin{javacode}
        ServiceLoader<CodeProvider> loader = ServiceLoader.load(CodeProvider.class);
        |\hyperref[lst:CodeProvider]{CodeProvider}| codeProvider = loader.iterator().next();
        |\hyperref[lst:CodeFactory]{CodeFactory}| factory = codeProvider.getInstance();
\end{javacode}
\caption{retrieve of the CodeProvider}
\label{lst:getCodeProvider}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Once an instance of \textsl{CodeFactory} has been retrieved, it is possible to 
create the definitions of the data-strings and generate the sources of the 
data-classes.

%--------1---------2---------3---------4---------5---------6---------7---------8
Two \textsl{clients} have been developed, one in the form of a maven plugin 
(\verb!recfm-maven-plugin!), and the other in the form of a gradle plugin 
(\verb!recfm-gradle-plugin!). 
The code is largely identical, only the trigger mechanism changes.

\chapter{Maven plugin}\label{sec:maven}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!recfm-maven-plugin! maven plugin allows you to create multiple classes 
and interfaces using one or more configuration files in yaml format. 
The external libraries used require java 8, so you need at least java 8 to run 
this plugin.

The plugin expects configuration parameters as parameters:
\begin{elisting}[!htb]
\begin{javacode}
    @Parameter(defaultValue = "${project.build.directory}/generated-sources/recfm",
        property = "maven.recfm.generateDirectory", required = true)
    private File generateDirectory;

    @Parameter(defaultValue = "${project.build.resources[0].directory}",
        property = "maven.recfm.settingsDirectory", required = true)
    private File settingsDirectory;
    
    @Parameter(required = true)
    private String[] settings;

    @Parameter(defaultValue = "true", property = "maven.recfm.addCompileSourceRoot")
    private boolean addCompileSourceRoot = true;

    @Parameter(defaultValue = "false", property = "maven.recfm.addTestCompileSourceRoot")
    private boolean addTestCompileSourceRoot = false;
    
    @Parameter
    private String codeProviderClassName;
\end{javacode}
\caption{settable parameters of the maven plugin}
\label{lst:maven.conf}
\end{elisting}

\begin{itemize}
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \index{plugin!generateDirectory}
    The \fcolorbox{black}{yellow!75}{\texttt{generateDirectory}} field indicates 
    the root directory to use for generating the sources, it is used to set the 
    value of the \verb!sourceDirectory! field of the 
    \hyperref[lst:GenerateArgs]{\texttt{GenerateArgs}} class, as can be seen 
    from the definition, if the parameter is omitted the 
    \verb!target/generated-sources/recfm! directory is used, normally the 
    default value can be left. 
    The other three parameters of \texttt{GenerateArgs} are an identifier of the 
    \textsl{service} program and are set automatically.
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \index{plugin!settingsDirectory}
    The \fcolorbox{black}{yellow!75}{\texttt{settingsDirectory}} field indicates 
    the directory containing the configuration files, if the parameter is 
    omitted the value \verb!src/main/resources! is used, normally the default 
    value can be left.
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \index{plugin!settings}
    The \fcolorbox{black}{yellow!75}{\texttt{settings}} field indicates the list 
    of configuration files to be used to generate the classes/interfaces; the 
    parameter must be supplied to the plugin.
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \index{plugin!addCompileSourceRoot}
    The \fcolorbox{black}{yellow!75}{\texttt{addCompileSourceRoot}} field is a 
    technical field, it indicates to maven that the directory where the sources 
    were generated must be included among those used for the main compilation, 
    if the parameter is omitted the value \verb!true! is used; the \verb!true! 
    value is appropriate when a code generation directory other than 
    \verb!src/main/java! is used, otherwise it is necessary to use additional 
    plugins to add the new path to the maven compilation path.
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \index{plugin!addTestCompileSourceRoot}
    The \fcolorbox{black}{yellow!75}{\texttt{addTestCompileSourceRoot}} field is 
    similar to the previous field, but adds the generation directory to the test 
    compilation path, if omitted the value \verb!false! is used, except in 
    special cases the default value can be left.
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \index{plugin!codeProviderClassName}
    The \fcolorbox{black}{yellow!75}{\texttt{codeProviderClassName}} field 
    indicates which is the concreated class that implements the 
    \textsl{Service Interface}, if omitted the ``first'' implementation of the 
    \textsl{ServiceLoader} retrieved is used; if there is only one 
    implementation in the classpath, it is not necessary to set the parameter.
\end{itemize}
%--------1---------2---------3---------4---------5---------6---------7---------8

%--------1---------2---------3---------4---------5---------6---------7---------8
\begin{elisting}[!htb]
\begin{xmlcode}
<plugin>
    <groupId>io.github.epi155</groupId>
    <artifactId>recfm-maven-plugin</artifactId>
    <version>0.7.0</version>
    <executions>
        <execution>
            <goals>
                <goal>generate</goal>
            </goals>
            <configuration>
                <settings>
                    <setting>foo.yaml</setting>
                </settings>
            </configuration>
        </execution>
    </executions>
    <dependencies>
        <dependency>
            <groupId>io.github.epi155</groupId>
            <artifactId>recfm-java-addon</artifactId>
            <version>0.7.0</version>
        </dependency>
    </dependencies>
</plugin>
\end{xmlcode}
\caption{minimal example of plugin execution}
\label{lst:mvn-xmpl}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
An example of plugin execution is shown in the lst.~\ref{lst:mvn-xmpl}, the 
plugin to be executed must have as dependency a library that provides the 
implementation of the interface, otherwise the \verb!ServiceLoader! does not 
find anything and the plugin terminates in error.

%--------1---------2---------3---------4---------5---------6---------7---------8
All other parameters are provided in the configuration files.

\section{Configuration file structure}
%--------1---------2---------3---------4---------5---------6---------7---------8
To manage the layout configuration the plugin defines the \textsl{MasterBook} 
class, see lst.~\ref{lst:MasterBook}, is divided into two components, the first 
\texttt{defaults} is simply the java-bean \textsl{FieldDefault} 
(see~\ref{lst:FieldDefault}) made available by the 
\textsl{Service Provider Interface} to provide the default values of the 
``slightly variable'' parameters of the classes and fields.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class MasterBook {
    private |\hyperref[lst:FieldDefault]{FieldDefault}| defaults = new FieldDefault();
    private List<|\hyperref[lst:ClassPackage]{ClassPackage}|> packages = new ArrayList<>();
}
\end{javacode}
\caption{MasterBook configuration class}
\label{lst:MasterBook}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
To simplify the enhancement of the yaml configuration file, a feature of the 
yaml libraries is used, which allows you to define abbreviated or alternative 
names of the parameters and values of the enum type fields. 
The component details of the \texttt{defaults} field will be shown along with 
the field it supplies the default parameter value to.
%--------1---------2---------3---------4---------5---------6---------7---------8

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class ClassPackage {
    private String name;     // package name
    private List<|\hyperref[lst:TraitModel]{TraitModel}|> interfaces = new ArrayList<>();
    private List<|\hyperref[lst:ClassModel]{ClassModel}|> classes = new ArrayList<>();
}
\end{javacode}
\caption{classe di configurazione ClassPackage}
\label{lst:ClassPackage}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The second component of \textsl{MasterBook}, \texttt{packages}, is a list of 
\textsl{ClassPackage} (\ref{lst:ClassPackage}), i.e. packages within which a 
list of interfaces and classes are defined. 
Expanding an example of this object in yaml format (with relative default) 
we have:

\begin{elisting}[!htb]
\begin{yamlcode}
defaults:
  cls:
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    doc: true
packages:
  - name: com.example.test  # package name
    interfaces:
      - &IFoo         # interface reference
        name: IFoo    # interface name
        length: 12    # :len: interface length
        fields:
          - ...
    classes:
      - name: Foo           # class name
        length: 10          # :len: class length
        onOverflow: Trunc   # :ovf: Error, Trunc
        onUnderflow: Pad    # :unf: Error, Pad
        fields:
          - ...
\end{yamlcode}
\caption{configuration, packages / interfaces / classes areas}
\label{lst:pakg-conf}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The possible alternative names of the fields and the list of allowed 
\textsl{enum} values are shown in the comments. 
If no interfaces are used, the \texttt{interfaces} node can be omitted. 
For both classes and interfaces, the name and length of the path to be 
associated must be set by the user, in the definition of the class the behavior 
can also be set if a structure with a larger size is provided during 
the de-serialization phase or less than expected.

\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{interfaces \quad \hyperref[lst:TraitModel]{TraitModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&name     &     & String  & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\hline
\hyperref[lst:ClsDefault]{ClsDefault}
&doc        &     & boolean & & \texttt{\$\{defaults.cls.doc:true\}}\\
\hline \multicolumn{1}{c|}{} 
&fields     &     & array & \ding{52} & \\
\cline{2-6}
\end{tabular}
%--------1---------2---------3---------4---------5---------6---------7---------8
\caption{Attributes that can be set for defining an interface} 
\label{tab:attr.trait}
\end{table}

%--------1---------2---------3---------4---------5---------6---------7---------8
Although all field types have a starting position and length, the detail of the 
configuration parameters varies from field to field and it is necessary to enter 
the configuration parameters field by field.

\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{classes \quad \hyperref[lst:ClassModel]{ClassModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&name     &     & String  & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\hline
\parbox[t]{15mm}{\multirow{3}{*}{\rotatebox[origin=c]{45}{\hyperref[lst:ClsDefault]{ClsDefault}}}}
%\multirow{3}{*}{\hyperref[lst:ClsDefault]{ClsDefault}}
&onOverflow & ovf & \hyperref[lst:LoadOverflowAction]{enum} & & \texttt{\$\{defaults.cls.onOverflow:Trunc\}}\\
\cline{2-6} 
&onUnderlow & unf & \hyperref[lst:LoadUnderflowAction]{enum} & & \texttt{\$\{defaults.cls.onUnderflow:Pad\}}\\
\cline{2-6} 
&doc        &     & boolean & & \texttt{\$\{defaults.cls.doc:true\}}\\
\hline \multicolumn{1}{c|}{}
&fields     &     & array & \ding{52} & \\
\cline{2-6}
\end{tabular}
%--------1---------2---------3---------4---------5---------6---------7---------8
\caption{Attributes that can be set for the definition of a class} 
\label{tab:attr.class}
\end{table}

%--------1---------2---------3---------4---------5---------6---------7---------8
To explicitly indicate the type of field used, \textsl{tag} are introduced to be 
associated with each field. Table~\ref{tab:tag.class} shows the tags associated 
with each type of field.

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}l|l|}
\hline
\multicolumn{3}{|c|}{Field definition tag}\\
\hline
\multicolumn{1}{|c|}{tag} & \multicolumn{1}{c|}{class} 
	& \multicolumn{1}{c|}{note} \\
\hline
\hline
\hyperref[sub:yaml.abc]{!Abc} & \hyperref[lst:AbcModel]{AbcModel} & alphanumeric field \\
\hline
\hyperref[sub:yaml.num]{!Num} & \hyperref[lst:NumModel]{NumModel} & numeric field \\
\hline
\hyperref[sub:yaml.cus]{!Cus} & \hyperref[lst:CusModel]{CusModel} & custom field \\
\hline
\hyperref[sub:yaml.nux]{!Nux} & \hyperref[lst:NuxModel]{NuxModel} & Nullable numeric field \\
\hline
\hyperref[sub:yaml.dom]{!Dom} & \hyperref[lst:DomModel]{DomModel} & domain field \\
\hline
\hyperref[sub:yaml.fil]{!Fil} & \hyperref[lst:FilModel]{FilModel} & filler field \\
\hline
\hyperref[sub:yaml.val]{!Val} & \hyperref[lst:ValModel]{ValModel} & constant field \\
\hline
\hyperref[sub:yaml.grp]{!Grp} & \hyperref[lst:GrpModel]{GrpModel} & field group of fields \\
\hline
\hyperref[sub:yaml.occ]{!Occ} & \hyperref[lst:OccModel]{OccModel} & field group of repeating fields \\
\hline
\hyperref[sub:yaml.emb]{!Emb} & \hyperref[lst:EmbModel]{EmbModel} & fields embedded via interface \\
\hline
\hyperref[sub:yaml.igrp]{!GRP} & \hyperref[lst:GrpTraitModel]{GrpTraitModel} & field group of fields via interface \\
\hline
\hyperref[sub:yaml.iocc]{!OCC} & \hyperref[lst:OccTraitModel]{OccTraitModel} & field group of repeating fields via interface \\
\hline
\end{tabular}
%--------1---------2---------3---------4---------5---------6---------7---------8
\caption{Yaml tag for field identification} 
\label{tab:tag.class}
\end{table}

\begin{quote}\small\bf
%--------1---------2---------3---------4---------5---------6---------7---------8
With regard to the offset of the fields, it should be noted that some 
characteristics do not depend on the \textsl{Service}, but on the 
\textsl{Service Provider}: the minimum offset can be zero or one, the offset 
setting can be mandatory or optional (the offset can be calculated automatically 
using the offset and length of the previous field), or not allowed.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{Service Provider} described in \S~\ref{sec:java.addon} uses a 
minimum offset of 1 and setting the offset is optional. If you omit the offset 
in a field defined with an override, it is assumed that the field overrides the 
field that precedes it in the structure definition. 
When defining interfaces the use of the offset is optional, but unlike classes, 
which require a minimum offset of 1, any initial value can be used for 
interfaces, the effective offset is corrected when the interface is applied to 
the class.
\end{quote}

\section{Single fields}

\subsection{Alphanumeric field} \label{sub:yaml.abc}
%--------1---------2---------3---------4---------5---------6---------7---------8
The yaml definition of the alphanumeric field reflects the structure imposed by 
the service provider interface, see~\ref{lst:AbcModel}. 
An alphanumeric field is specified by indicating the 
\fcolorbox{black}{yellow!75}{\texttt{!Abc}} \textsl{tag} , an example of 
defining alphanumeric fields is shown in lst.~\ref{lst:xmplAbc}, the example 
also shows the global default node for alphanumeric fields, the values set are 
the default ones of the \textsl{service provider interface}, so it is not 
necessary to explicitly set the parameters if you want to set these values.

\begin{elisting}[!htb]
\begin{yamlcode}
defaults:
  abc:
    check: Ascii        # :chk: None, Ascii, Latin1, Valid
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    normalize: None     # :nrm: None, Trim, Trim1
    checkGetter: true   # :get:
    checkSetter: true   # :set:
packages:
  - name: com.example.test
    classes:
      - name: Foo3111
        length: 55
        fields:
          - !Abc { name: firstName   , at:  1, len: 15 }
          - !Abc { name: lastName    , at: 16, len: 15 }
          - !Num { name: birthDate   , at: 31, len:  8 }
          - !Abc { name: birthPlace  , at: 39, len: 14 }
          - !Abc { name: birthCountry, at: 53, len:  3 }
\end{yamlcode}
\caption{example of definition of alphanumeric fields}
\label{lst:xmplAbc}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
In the example, the default node of alphanumeric fields is set using the 
canonical names of the parameters. The \textit{plugin} uses an available 
functionality of the library to read the yaml file, and defines short parameter 
names, which can be used as an alternative to the canonical names.

\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{\texttt{!Abc}: \hyperref[lst:AbcModel]{AbcModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&offset     & at  & int     & {\color{lightgray}\ding{52}} & self-calculated \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&name       &     & String  & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&override   & ovr & boolean & & \texttt{false} \\
\hline
\parbox[t]{2.5mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{\hyperref[lst:AbcDefault]{AbcDefault}}}}
&onOverflow & ovf & \hyperref[lst:OverflowAction]{enum} & & \texttt{\$\{defaults.abc.onOverflow:Trunc\}}\\
\cline{2-6}
&onUnderlow & unf & \hyperref[lst:UnderflowAction]{enum} & & \texttt{\$\{defaults.abc.onUnderflow:Pad\}}\\
\cline{2-6}
&check      & chk & \hyperref[lst:CheckAbc]{enum} & & \texttt{\$\{defaults.abc.check:Ascii\}}\\
\cline{2-6}
&normalize  & nrm & \hyperref[lst:NormalizeAbcMode]{enum} & & \texttt{\$\{defaults.abc.normalize:None\}}\\
\cline{2-6}
&checkGetter & get & boolean & & \texttt{\$\{defaults.abc.checkGetter:true\}}\\
\cline{2-6}
&checkSetter & set & boolean & & \texttt{\$\{defaults.abc.checkSetter:true\}}\\
\hline
\end{tabular}
\caption{Attributes that can be set for an alphanumeric field} \label{tab:attr.abc}
\end{table}

%--------1---------2---------3---------4---------5---------6---------7---------8
Table~\ref{tab:attr.abc} shows all the attributes expected for an alphanumeric 
field, the relative abbreviated names, the corresponding data-type, whether the 
attribute is mandatory or optional, and any default value.

\subsection{Numeric field} \label{sub:yaml.num}
%--------1---------2---------3---------4---------5---------6---------7---------8
The yaml definition of the numeric field reflects the structure imposed by the 
service interface, see~\ref{lst:NumModel}. 
A numeric field is specified by indicating the  
\fcolorbox{black}{yellow!75}{\texttt{!Num}} \textsl{tag}, an example of defining
numeric fields is shown in the lst.~\ref{lst:xmplNum}, the example also shows 
the global default node for numeric fields, the values set are the default ones 
of the \textsl{service provider interface}, so it is not necessary to explicitly 
set the parameters if you want to set these values.

\begin{elisting}[!htb]
\begin{yamlcode}
defaults:
  num:
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    normalize: None     # :nrm: None, Trim
    wordWidth: Int      # :wid: Byte(1,byte), Short(2,short), Int(4,int), Long(8,long)
    access: String      # :acc: String(Str), Numeric(Num), Both(All)
packages:
  - name: com.example.test
    classes:
      - name: Foo3112
        length: 8
        doc: No
        fields:
          - !Num { name: year , at: 1, len: 4 }
          - !Num { name: month, at: 5, len: 2 }
          - !Num { name: mday , at: 7, len: 2 }
\end{yamlcode}
\caption{example of definition of numeric fields}
\label{lst:xmplNum}
\end{elisting}


\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{\texttt{!Num}: \hyperref[lst:NumModel]{NumModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&offset     & at  & int     & {\color{lightgray}\ding{52}} & self-calculated \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&name       &     & String  & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&override   & ovr & boolean & & \texttt{false} \\
\hline
\parbox[t]{2.5mm}{\multirow{5}{*}{\rotatebox[origin=c]{90}{\hyperref[lst:NumDefault]{NumDefault}}}}
&onOverflow & ovf & \hyperref[lst:OverflowAction]{enum} & & \texttt{\$\{defaults.num.onOverflow:Trunc\}}\\
\cline{2-6}
&onUnderlow & unf & \hyperref[lst:UnderflowAction]{enum} & & \texttt{\$\{defaults.num.onUnderflow:Pad\}}\\
\cline{2-6}
&access     & acc & \hyperref[lst:AccesMode]{enum} & & \texttt{\$\{defaults.num.access:String\}}\\
\cline{2-6}
&wordWidth  & wid & \hyperref[lst:WordWidth]{enum} & & \texttt{\$\{defaults.num.wordWidth:Int\}}\\
\cline{2-6}
&normalize  & nrm & \hyperref[lst:NormalizeNumMode]{enum} & & \texttt{\$\{defaults.num.normalize:None\}}\\
\hline
\end{tabular}
\caption{Attributes that can be set for a numeric field} \label{tab:attr.num}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Table~\ref{tab:attr.num} shows all the attributes expected for a numeric field, 
the relative abbreviated names, the corresponding data-type, whether the 
attribute is mandatory or optional, and any default value. 
%--------1---------2---------3---------4---------5---------6---------7---------8
Even if the \texttt{acccess} and \texttt{wordWidth} parameters were introduced 
in \S~\ref{sec:spi.num}, I remind you that a ``numeric'' field can be managed as 
a string (where only numeric characters are allowed), or converted into a native 
numeric format, or both. The \texttt{access} parameter indicates whether to 
create string setters/getters only, create numeric setters/getters only, or 
both. 
%--------1---------2---------3---------4---------5---------6---------7---------8
In case a native number representation is used, the \texttt{wordWidth} parameter 
indicates the minimum size native representation to use. 
In general the \textsl{Service Provider} will select the size of the native 
representation based on the size of the data-string that will end up r
epresenting the value of the field.


\subsection{Custom field (alphanumeric)} \label{sub:yaml.cus}
%--------1---------2---------3---------4---------5---------6---------7---------8
The yaml definition of the custom field reflects the structure 
imposed by the service provider interface, see~\ref{lst:CusModel}.
A custom field is specified by indicating the 
\fcolorbox{black}{yellow!75}{\texttt{!Cus}} \textsl{tag}, an example of defining 
custom fields is shown in the lst.~\ref{lst:xmplCus}, in the 
example the global default node for the custom fields is also shown, the values 
set are the default ones of the \textsl{service provider interface}, therefore 
it is not necessary to explicitly set the parameters if you want to set these 
values.

%--------1---------2---------3---------4---------5---------6---------7---------8
A custom field is an extension of an alphanumeric field. An alphanumeric field 
is necessarily left-aligned, right-truncated/trimmed, right-padded with spaces, 
initialized to spaces. In a custom field it is possible to choose the alignment 
of the field, the padding and initialization character; it has an extended 
\texttt{check} with respect to the alphanumeric one, finally, the \texttt{regex} 
attribute can be used to validate the values allowed for the field (instead of 
the one defined with \texttt{check}).

\begin{elisting}[!htb]
\begin{yamlcode}
defaults:
  cus:
    padChar: ' '        # :pad:
    initChar: ' '       # :ini:
    check: Ascii        # :chk: None, Ascii, Latin1, Valid, Digit, DigitOrBlank
    align: LFT          # LFT, RGT
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    normalize: None     # :nrm: None, Trim, Trim1
    checkGetter: true   # :get:
    checkSetter: true   # :set:
packages:
  - name: com.example.test
    classes:
      - name: Foo3113
        length: 8
        doc: No
        fields:
          - !Cus { name: year , at: 1, len: 4 }
          - !Cus { name: month, at: 5, len: 2 }
          - !Cus { name: mday , at: 7, len: 2 }
\end{yamlcode}
\caption{example of definition of custom fields}
\label{lst:xmplCus}
\end{elisting}

\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{\texttt{!Cus}: \hyperref[lst:CusModel]{CusModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&offset     & at  & int     & {\color{lightgray}\ding{52}} & self-calculated \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&name       &     & String  & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&override   & ovr & boolean & & \texttt{false} \\
\hline
\parbox[t]{2.5mm}{\multirow{9}{*}{\rotatebox[origin=c]{90}{\hyperref[lst:CusDefault]{CusDefault}}}}
&onOverflow & ovf & \hyperref[lst:OverflowAction]{enum} & & \texttt{\$\{defaults.cus.onOverflow:Trunc\}}\\
\cline{2-6}
&onUnderlow & unf & \hyperref[lst:UnderflowAction]{enum} & & \texttt{\$\{defaults.cus.onUnderflow:Pad\}}\\
\cline{2-6}
&padChar    & pad & char    & & \texttt{\$\{defaults.cus.pad:' '\}}\\
\cline{2-6}
&initChar   & ini & char    & & \texttt{\$\{defaults.cus.ini:' '\}}\\
\cline{2-6}
&check      & chk & \hyperref[lst:CheckCus]{enum} & & \texttt{\$\{defaults.cus.check:Ascii\}}\\
\cline{2-6}
&align      &     & \hyperref[lst:AlignMode]{enum} & & \texttt{\$\{defaults.cus.align:LFT\}}\\
\cline{2-6}
&normalize  & nrm & \hyperref[lst:NormalizeAbcMode]{enum} & & \texttt{\$\{defaults.cus.normalize:None\}}\\
\cline{2-6}
&checkGetter & get & boolean & & \texttt{\$\{defaults.cus.checkGetter:true\}}\\
\cline{2-6}
&checkSetter & set & boolean & & \texttt{\$\{defaults.cus.checkSetter:true\}}\\
\hline \multicolumn{1}{c|}{}
&regex      &     & String  & & \texttt{null} \\
\cline{2-6}
\end{tabular}
\caption{Attributes that can be set for a custom field} \label{tab:attr.cus}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Table~\ref{tab:attr.cus} shows all the attributes expected for a 
custom field, the related abbreviated names, the corresponding 
data-type, whether the attribute is mandatory or optional, and any default value.

\subsection{Nullable numeric field} \label{sub:yaml.nux}
%--------1---------2---------3---------4---------5---------6---------7---------8
The yaml definition of the nullable numeric field reflects the structure imposed 
by the service interface, see~\ref{lst:NuxModel}. 
A nullable numeric field is specified by indicating the 
\fcolorbox{black}{yellow!75}{\texttt{!Nux}} \textsl{tag}, an example of the 
definition of nullable numeric fields is shown in the lst.~\ref{lst:xmplNux}, 
the example also shows the global default node for nullable numeric fields, the 
values set are the default ones of the \textsl{service provider interface}, so 
it is not necessary to explicitly set the parameters if you want to set these 
values.

\begin{elisting}[!htb]
\begin{yamlcode}
defaults:
  nux:
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    normalize: None     # :nrm: None, Trim
    wordWidth: Int      # :wid: Byte(1,byte), Short(2,short), Int(4,int), Long(8,long)
    access: String      # :acc: String(Str), Numeric(Num), Both(All)
    initialize: Spaces  # :ini: Spaces(Space), Zeroes(Zero)
packages:
  - name: com.example.test
    classes:
      - name: Foo3114
        length: 8
        doc: No
        fields:
          - !Nux { name: year , at: 1, len: 4 }
          - !Nux { name: month, at: 5, len: 2 }
          - !Nux { name: mday , at: 7, len: 2 }
\end{yamlcode}
\caption{example of definition of nullable numeric fields}
\label{lst:xmplNux}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
A nullable numeric field is an extension of an ordinary numeric field, the 
difference is that in the string-data representation it can assume the value 
space (all spaces), which corresponds to the \texttt{null} value in the data 
class. 
Consequently, in the definition of the field there is an additional parameter to
indicate whether the field must be initialized to \texttt{null} or to zero when 
the data-class is created with the empty constructor.

\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{\texttt{!Nux}: \hyperref[lst:NuxModel]{NuxModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&offset     & at  & int     & {\color{lightgray}\ding{52}} & self-calculated \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&name       &     & String  & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&override   & ovr & boolean & & \texttt{false} \\
\hline
\parbox[t]{2.5mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{\hyperref[lst:NuxDefault]{NuxDefault}}}}
&onOverflow & ovf & \hyperref[lst:OverflowAction]{enum} & & \texttt{\$\{defaults.nux.onOverflow:Trunc\}}\\
\cline{2-6}
&onUnderlow & unf & \hyperref[lst:UnderflowAction]{enum} & & \texttt{\$\{defaults.nux.onUnderflow:Pad\}}\\
\cline{2-6}
&access     & acc & \hyperref[lst:AccesMode]{enum} & & \texttt{\$\{defaults.nux.access:String\}}\\
\cline{2-6}
&wordWidth  & wid & \hyperref[lst:WordWidth]{enum} & & \texttt{\$\{defaults.nux.wordWidth:Int\}}\\
\cline{2-6}
&normalize  & nrm & \hyperref[lst:NormalizeNumMode]{enum} & & \texttt{\$\{defaults.nux.normalize:None\}}\\
\cline{2-6}
&initialize & ini & \hyperref[lst:InitializeNuxMode]{enum} & & \texttt{\$\{defaults.nux.initialize:Space\}}\\
\hline
\end{tabular}
\caption{Attributes that can be set for a nullable numeric field} \label{tab:attr.nux}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Table~\ref{tab:attr.nux} shows all the attributes expected for a numeric field, 
the relative abbreviated names, the corresponding data-type, whether the 
attribute is mandatory or optional, and any default value.

\subsection{Domain field} \label{sub:yaml.dom}
%--------1---------2---------3---------4---------5---------6---------7---------8
The yaml definition of the numeric field reflects the structure imposed by the 
service interface, see~\ref{lst:DomModel}. 
A domain field is specified by indicating the 
\fcolorbox{black}{yellow!75}{\texttt{!Dom}} \textsl{tag}, an example of domain 
field definition is shown in the lst.~\ref{lst:xmplDom}, this field type has no 
global default.

\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    classes:
      - name: Foo3115
        length: 12
        doc: No
        fields:
          - !Num { name: year , at: 1, len: 4 }
          - !Dom { name: month, at: 5, len: 3, 
                   items: [ Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec ] }
          - !Num { name: mday , at: 8, len: 2 }
          - !Dom { name: wday , at: 10, len: 3, 
                   items: [ Sun, Mon, Tue, Wed, Thu, Fri, Sat ] }
\end{yamlcode}
\caption{example of definition of domain fields}
\label{lst:xmplDom}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
A domain field is substantially an alphanumeric field, which can assume only a 
limited number of values.

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!Dom}: \hyperref[lst:DomModel]{DomModel}}\\
\hline
\multicolumn{1}{|c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & self-calculated \\
\hline
length     & len & int     & \ding{52} & \\
\hline
name       &     & String  & \ding{52} & \\
\hline
override   & ovr & boolean & & \texttt{false} \\
\hline
items      &     & array  & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributes that can be set for a domain field} \label{tab:attr.dom}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Table~\ref{tab:attr.dom} shows all the attributes expected for a domain field, 
the related abbreviated names, the corresponding data-type, whether the 
attribute is mandatory or optional, and any default value. 
When the data-class is created with the empty constructor, the field is 
initialized with the first value among those provided in the list of possible 
values.

\subsection{Filler Field} \label{sub:yaml.fil}
%--------1---------2---------3---------4---------5---------6---------7---------8
The yaml definition of the filler field reflects the structure imposed by the 
service interface, see~\ref{lst:FilModel}. 
A filler field is specified by indicating the 
\fcolorbox{black}{yellow!75}{\texttt{!Fil}} \textsl{tag}, an example of 
definition of filler fields is shown in the lst.~\ref{lst:xmplFil}, in the 
example the global default node for the filler fields is also shown, the set 
value is the default one of the service provider interface, therefore it is not 
necessary to explicitly set the parameter if you want to set this value.

\begin{elisting}[!htb]
\begin{yamlcode}
defaults:
  fil:
    fill: 0             # \u0000
packages:
  - name: com.example.test
    classes:
      - name: Foo3116
        length: 10
        doc: No
        fields:
          - !Num { at: 1, len: 4, name: year }
          - !Fil { at: 5, len: 1, fill: '-' }
          - !Num { at: 6, len: 2, name: month }
          - !Fil { at: 8, len: 1, fill: '-' }
          - !Num { at: 9, len: 2, name: mday }
\end{yamlcode}
\caption{example of definition of filler fields}
\label{lst:xmplFil}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
A filler field is not a real field, the setters/getters are not generated, no 
check is made on the value of the corresponding data-string. It simply indicates 
an area of the data-string that we are not interested in, but which must be 
present in the definition of the structure in order not to leave undefined areas.

\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{\texttt{!Fil}: \hyperref[lst:FilModel]{FilModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&offset     & at  & int     & {\color{lightgray}\ding{52}} & self-calculated \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\hline
\hyperref[lst:FilDefault]{FilDefault}
&fill       &     & char    & & \texttt{\$\{defaults.fil.fill:0\}}\\
\hline
\end{tabular}
\caption{Attributes that can be set for a filler field} \label{tab:attr.fil}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Table~\ref{tab:attr.fil} shows all the attributes expected for a filler field, 
the relative abbreviated names, the corresponding data-type, whether the 
attribute is mandatory or optional, and any default value.


\subsection{Constant field} \label{sub:yaml.val}
%--------1---------2---------3---------4---------5---------6---------7---------8
The yaml definition of the constant field reflects the structure imposed by the 
service interface, see 19. A constant field is specified by indicating the 
\fcolorbox{black}{yellow!75}{\texttt{!Val}} \textsl{tag}, an example of 
definition of cotant fields is shown in the lst.~\ref{lst:xmplVal}, this type of 
field has no global defaults.

\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    classes:
      - name: Foo3117
        length: 10
        fields:
          - !Num { at: 1, len: 4, name: year }
          - !Val { at: 5, len: 1, val: "-" }
          - !Num { at: 6, len: 2, name: month }
          - !Val { at: 8, len: 1, val: "-" }
          - !Num { at: 9, len: 2, name: mday }
\end{yamlcode}
\caption{example of definition of constant fields}
\label{lst:xmplVal}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
A constant field can be thought of as a variant of a filler field, or as a 
domain field with only one value. Setters/getters are not generated for this 
type of field, but the field is checked to verify that the data-string 
corresponding to the field has the expected value.

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!Val}: \hyperref[lst:ValModel]{ValModel}}\\
\hline
\multicolumn{1}{|c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & self-calculated \\
\hline
length     & len & int     & \ding{52} & \\
\hline
value      & val & string  & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributes that can be set for a constant range} \label{tab:attr.val}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Table~\ref{tab:attr.val} shows all the attributes required for a constant field, 
the relative abbreviated names, the corresponding data-type, whether the 
attribute is mandatory or optional, and any default value.

\section{Manifold fields}
%--------1---------2---------3---------4---------5---------6---------7---------8
In some cases it is useful to group some fields within a context containing 
element. This way you can use the same field name in different contexts. 
A manifold field has no global defaults.

\subsection{Field group of fields} \label{sub:yaml.grp}
%--------1---------2---------3---------4---------5---------6---------7---------8
The yaml definition of the field group field reflects the structure imposed by 
the service interface, see~\ref{lst:GrpModel}. 
A field group field is specified by indicating the 
\fcolorbox{black}{yellow!75}{\texttt{!Grp}} \textsl{tag}, an example of this 
field definition is shown in the lst.~\ref{lst:xmplGrp}.

\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    classes:
      - name: Foo3118
        length: 12
        fields:
          - !Grp { name: startTime, at: 1, len: 6, fields: [
            !Num { name: hours  , at: 1, len: 2 }, 
            !Num { name: minutes, at: 3, len: 2 }, 
            !Num { name: seconds, at: 5, len: 2 }
            ] }
          - !Grp { name: stopTime , at: 7, len: 6, fields: [
            !Num { name: hours  , at:  7, len: 2 }, 
            !Num { name: minutes, at:  9, len: 2 }, 
            !Num { name: seconds, at: 11, len: 2 }
            ] }
\end{yamlcode}
\caption{example definition group of fields}
\label{lst:xmplGrp}
\end{elisting}

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!Grp}: \hyperref[lst:GrpModel]{GrpModel}}\\
\hline
\multicolumn{1}{|c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & self-calculated \\
\hline
length     & len & int     & \ding{52} & \\
\hline
name       &     & String  & \ding{52} & \\
\hline
override   & ovr & boolean & & \texttt{false} \\
\hline
fields     &     & array  & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributes that can be set for a group of fields} \label{tab:attr.grp}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Table~\ref{tab:attr.grp} shows all the attributes expected for a group of 
fields, their abbreviated names, the corresponding data-type, whether the 
attribute is mandatory or optional, and any default value.

\subsection{Field group of repeating fields} \label{sub:yaml.occ}
%--------1---------2---------3---------4---------5---------6---------7---------8
The yaml definition of the repeating field group field reflects the structure 
imposed by the service interface, see~\ref{lst:OccModel}. 
A repeating field group field is specified by indicating the 
\fcolorbox{black}{yellow!75}{\texttt{!Occ}} \textsl{tag}, an example of this 
field definition is shown in the lst.~\ref{lst:xmplOcc}.

\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    classes:
      - name: Foo3119
        length: 590
        fields:
          - !Num { name: nmErrors, at: 1, len: 2 }
          - !Occ { name: tabError, at: 3, len: 49, x: 12, fields: [
            !Abc { name: status  , at:  3, len:  5 },
            !Num { name: code    , at:  8, len:  4 },
            !Abc { name: message , at: 12, len: 40 }
          ] }
\end{yamlcode}
\caption{example definition group of repeated fields}
\label{lst:xmplOcc}
\end{elisting}

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!Occ}: \hyperref[lst:OccModel]{OccModel}}\\
\hline
\multicolumn{1}{|c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & self-calculated \\
\hline
length     & len & int     & \ding{52} & \\
\hline
name       &     & String  & \ding{52} & \\
\hline
override   & ovr & boolean & & \texttt{false} \\
\hline
times      & x   & int     & \ding{52} & \\
\hline
fields     &     & array  & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributes that can be set for a repeating field group} 
\label{tab:attr.occ}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Table~\ref{tab:attr.occ} shows all the attributes expected for a field group of 
repeated fields, the related abbreviated names, the corresponding data-type, 
whether the attribute is mandatory or optional, and any default value.

\subsection{Fields embedded via interface} \label{sub:yaml.emb}
%--------1---------2---------3---------4---------5---------6---------7---------8
The yaml definition of embedded fields via interface reflects the structure 
imposed by the service interface, see~\ref{lst:EmbModel}. 
An embedded field is specified by indicating the 
\fcolorbox{black}{yellow!75}{\texttt{!Emb}} \textsl{tag}, an example of this 
field definition is shown in the lst.~\ref{lst:xmplEmb}.

\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    interfaces:
      - &Time
        name: ITime
        len: 6
        fields:
          - !Num { name: hours  , len: 2 }
          - !Num { name: minutes, len: 2 }
          - !Num { name: seconds, len: 2 }
    classes:
      - name: Foo311a
        length: 14
        fields:
          - !Num { name: year , at: 1, len: 4 }
          - !Num { name: month, at: 5, len: 2 }
          - !Num { name: mday , at: 7, len: 2 }
          - !Emb { src: *Time , at: 9, len: 6 }
\end{yamlcode}
\caption{example definition of embedded fields via interface}
\label{lst:xmplEmb}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Interfacing embedded fields unlike other manifold fields does not create an 
explicit context item. Fields are children of the current structure, not of a 
context item. But the current element implements the interface and this creates 
an implicit context.

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!Emb}: \hyperref[lst:EmbModel]{EmbModel}}\\
\hline
\multicolumn{1}{|c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & self-calculated\\
\hline
length     & len & int     & \ding{52} & \\
\hline
source     & src  & interface & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributes that can be set for embedded fields via interface}
\label{tab:attr.emb}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Table~\ref{tab:attr.emb} shows all the attributes expected for an embedded 
fields via interface, the relative abbreviated names, the 
corresponding data-type, whether the attribute is mandatory or optional, and 
any default value.

\subsection{Field group of fields via interface} \label{sub:yaml.igrp}
%--------1---------2---------3---------4---------5---------6---------7---------8
The yaml definition of the interface-group field reflects the structure imposed 
by the service interface, see~\ref{lst:GrpTraitModel}. 
A group/interface field is specified by indicating the 
\fcolorbox{black}{yellow!75}{\texttt{!GRP}} \textsl{tag}, an example of a 
definition of this field is shown in the lst.~\ref{lst:xmplIGrp}.

\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    interfaces:
      - &Time
        name: ITime
        len: 6
        fields:
          - !Num { name: hours  , len: 2 }
          - !Num { name: minutes, len: 2 }
          - !Num { name: seconds, len: 2 }
    classes:
      - name: Foo311b
        length: 12
        fields:
          - !GRP { name: startTime, at: 1, len: 6, as: *Time }
          - !GRP { name: stopTime , at: 7, len: 6, as: *Time }
\end{yamlcode}
\caption{example definition of interface-group fields}
\label{lst:xmplIGrp}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
An interface-group field is similar to a group of fields, the difference is that 
the fields of the group are not defined individually, but all together by 
importing them from the interface. The group will implement the interface.

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!GRP}: \hyperref[lst:GrpTraitModel]{GrpTraitModel}}\\
\hline
\multicolumn{1}{|c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & self-calculated \\
\hline
length     & len & int     & \ding{52} & \\
\hline
name       &     & String  & \ding{52} & \\
\hline
override   & ovr & boolean & & \texttt{false} \\
\hline
typedef    & as  & interface & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributi impostabili per un gruppo da interfaccia} \label{tab:attr.igrp}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Table~\ref{tab:attr.igrp} shows all the attributes expected for an 
interface-group field, the relative abbreviated names, the corresponding 
data-type, whether the attribute is mandatory or optional, and any default value.

\subsection{Field group of repeating fields via interface} \label{sub:yaml.iocc}
%--------1---------2---------3---------4---------5---------6---------7---------8
The yaml definition of the repeating interface-group field reflects the 
structure imposed by the service interface, see~\ref{lst:OccTraitModel}. 
A repeating interface-group field is specified by indicating the 
\fcolorbox{black}{yellow!75}{\texttt{!OCC}} \textsl{tag}, an example definition 
of this field is shown in the lst.~\ref{lst:xmplIOcc}.

\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    interfaces:
      - &Error
        name: IError
        len: 49
        fileds:
          - !Abc { name: status  , at:  1, len:  5}
          - !Num { name: code    , at:  6, len:  4}
          - !Abc { name: message , at: 10, len: 40}
    classes:
      - name: Foo311c
        length: 590
        fields:
          - !Num { name: nmErrors, at: 1, len: 2}
          - !OCC { name: tabError, at: 3, len: 49, x: 12, as: *Error }
\end{yamlcode}
\caption{example definition of the repeated interface-group field}
\label{lst:xmplIOcc}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
A repeating interface-group field is similar to a repeating field group field, 
the difference is that the fields of the group are not defined individually, but 
all together by importing them from the interface. The group will implement the 
interface.

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!OCC}: \hyperref[lst:OccTraitModel]{OccTraitModel}}\\
\hline
\multicolumn{1}{|c|}{attribute} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{type} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & self-calculated \\
\hline
length     & len & int     & \ding{52} & \\
\hline
name       &     & String  & \ding{52} & \\
\hline
override   & ovr & boolean & & \texttt{false} \\
\hline
times      & x   & int     & \ding{52} & \\
\hline
typedef    & as  & interface & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributes that can be set for a repeating interface-group} 
\label{tab:attr.iocc}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Table~\ref{tab:attr.iocc} shows all the attributes expected for a group field 
repeated by the interface, the relative abbreviated names, the corresponding 
data-type, whether the attribute is mandatory or optional, and any default 
value.

\chapter{Gradle plugin}\label{sec:gradle}
%--------1---------2---------3---------4---------5---------6---------7---------8
The gradle plugin \verb!recfm-gradle-plugin! allows you to create multiple 
classes and interfaces using one or more configuration files in yaml format. 
The external libraries used require java 8, so you need at least java 8 to run 
this plugin.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!recfm-gradle-plugin! gradle plugin is simply an adaptation of the 
\verb!recfm-maven-plugin! for use in a gradle project. 
Apart from how the input parameters are passed, and how the plugin is activated, 
the code is the copy of the maven version.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class RecordFormatExtension {
    private String generateDirectory; // default: "${project.buildDir}/generated-sources/recfm"
    private String settingsDirectory; // default: "${project.projectDir}/src/main/resources"
    private String[] settings;
    private boolean addCompileSourceRoot = true;
    private boolean addTestCompileSourceRoot = false;
    private String codeProviderClassName;
}
\end{javacode}
\caption{settable parameters of the gradle plugin}
\label{lst:gradle.conf}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
As can be seen by comparing it with the lst.~\ref{lst:maven.conf} the parameters 
used are the same as those of the maven-plugin, for the description of the 
parameters refer to \S~\ref{sec:maven}.

\begin{elisting}[!htb]
\begin{minted}[frame=single,framesep=2mm,bgcolor=bg,fontsize=\footnotesize]{groovy}
buildscript {
    dependencies {
        // plugin
        classpath 'io.github.epi155:recfm-gradle-plugin:0.7.0'
        // addon for java code generation
        classpath 'io.github.epi155:recfm-java-addon:0.7.0'
    }
}
apply plugin: 'RecordFormatPlugin'
recfm {
    settings  'recfm-foo.yaml'
}
\end{minted}
\caption{minimal example of plugin execution}
\label{lst:grd-xmpl}
\end{elisting}


\part{Service Provider}\label{vol:sp}

\chapter{Service Provider}
%--------1---------2---------3---------4---------5---------6---------7---------8
In the previous chapters we have seen the \textsl{Service Provider Interface}, 
which defines interfaces and classes that allow you to define the layouts, and 
indicate some behaviors that must be used when using the layouts; 
and some examples of \textsl{Service}, which simply values the objects made 
available to the \textsl{Service Provider Interface}, but the real work of 
generating the code is done by the \textsl{Service Provider}.

%--------1---------2---------3---------4---------5---------6---------7---------8
The SPI structure allows you to have code generated differently, implemented 
differently, or even generate source in a different language.

%--------1---------2---------3---------4---------5---------6---------7---------8
Whatever the language generated and the detail of the implementation, the 
\textsl{Service Provider} will have to provide some general functions.

\begin{itemize}\setlength\itemsep{-0.5ex}
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \textbf{decode}: starting from the data-string, it must instantiate the 
    data-class;
\item \textbf{setter, getter}: the generated data-class must provide access 
    methods to the individual fields;
\item \textbf{empty constructor}: the data-class can be instantiated with the 
    default values of the fields;
\item \textbf{encode}: data-class can be serialized into data-string.
\end{itemize}
%--------1---------2---------3---------4---------5---------6---------7---------8
Some additional features would also be welcome:
\begin{itemize}\setlength\itemsep{-0.5ex}
\item \textbf{validate}: validate the data-string before de-serialization, in 
    order to signal all the areas that cannot be assigned to the relative 
    fields, typically non-numerical characters in numeric-type fields;
\item \textbf{cast}: if two data-strings have the same length, being able to 
    pass from one data-class that represents them to another;
\item \textbf{toString}: provide a method that displays all the values of the 
    fields that make up the data-class (in a human readable way, not the encode 
    method);
\item (deep) \textbf{copy}: generates a copy of the data-class;.
\end{itemize}

\section{Java source code generation --- \texttt{java-addon}} 
\label{sec:java.addon}
%--------1---------2---------3---------4---------5---------6---------7---------8
The classes generated by the java \textsl{CodeProvider} in addition to the 
setters and getters have a series of auxiliary methods, see 
lst.~\ref{lst:Foo312:java}.

%--------1---------2---------3---------4---------5---------6---------7---------8
\begin{itemize}\setlength\itemsep{-0.5ex}
\item a no-argument constructor is provided, which creates the class with 
    default values;
\item a cast-like constructor is provided, which takes any other class 
    representing a data-class as an argument;
\item a constructor is provided from string-data (deserializer);
\item a \textit{deep-copy} method is provided to duplicate the data-class;
\item a validation method is provided;
\item a \texttt{toString} method is provided;
\item a method is provided to generate the data-string (serializer);
\item a method is provided to retrieve the length of the data-string.
\end{itemize}

\begin{elisting}[!htb]
\begin{javacode}
public class Foo312 extends FixRecord {
    public Foo312() { /* ... */ }
    public static Foo312 of(FixRecord r) { /* ... */ }
    public static Foo312 decode(String s) { /* ... */ }
    public Foo312 copy() { /* ... */ }
    // setter and getter ...
    public boolean validateFails(|\hyperref[lst:FieldValidateHandler:java]{FieldValidateHandler}| handler) { /* ... */ }
    public boolean validateAllFails(|\hyperref[lst:FieldValidateHandler:java]{FieldValidateHandler}| handler) { /* ... */ }
    public String toString() { /* ... */ }
    public String encode() { /* ... */ }    // from super class
    public int length() { return LRECL; }   // string-data length
}
\end{javacode}
\caption{example of generated class (Foo312)}
\label{lst:Foo312:java}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Classes generated from configuration files inherit general classes with common 
methods for handling control setter/getter and validations. These classes are 
provided as an external library, see~\ref{lst:mvn-j-deps}.

\begin{elisting}[!htb]
\begin{xmlcode}
<dependencies>
  <dependency>
    <groupId>io.github.epi155</groupId>
    <artifactId>recfm-java-lib</artifactId>
    <version>0.7.0</version>
  </dependency>
</dependencies>
\end{xmlcode}
\caption{addon-java runtime dependencies}
\label{lst:mvn-j-deps}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
These libraries are compiled in java-5 compatibility, and contain the 
\textsl{module-info} in order to be correctly managed also with java-9 and 
higher.

\subsection{Validation}
%--------1---------2---------3---------4---------5---------6---------7---------8
As seen in the lst.~\ref{lst:Foo312:java} a validation method is generated for 
each class. 
The argument is a dedicated interface, but this is for pre-java-8 compatibility. 
The argument will be a \textit{closure}, implemented with an anonymous or 
internal class or a $\lambda$-function.

\begin{elisting}[!htb]
\begin{javacode}
public interface FieldValidateHandler {
    void error(|\hyperref[lst:FieldValidateError:java]{FieldValidateError}| fieldValidateError);
}
\end{javacode}
\caption{error handler \texttt{FieldValidateHandler}}
\label{lst:FieldValidateHandler:java}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The validation methods indicate whether the data-string acquired with the 
\texttt{decode} static constructor has passed the validation required by the 
definition of the fields or not, but every time a validation error is detected 
the \texttt{error} method of the interface supplied as an argument is called 
with the details of the error. In this way it is possible to accumulate all the 
validation errors detected. 
%--------1---------2---------3---------4---------5---------6---------7---------8
The difference between the two methods is that the first \texttt{validateFails} 
in case of multiple wrong characters on the same field, signals only the first, 
while the second \texttt{validateAllFails} signals all the characters in error.

\begin{elisting}[!htb]
\begin{javacode}
public interface FieldValidateError {
    String name();          // field name in error
    int offset();           // field offset in error
    int length();           // field length in error
    String value();         // field value in error
    Integer column();       // column of the record with the wrong character
    |\hyperref[lst:ValidateError:java]{ValidateError}| code();   // error category
    Character wrong();      // wrong character
    String message();       // field message error
}
\end{javacode}
\caption{error detail \texttt{FieldValidateError}}
\label{lst:FieldValidateError:java}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The argument to the \texttt{error} method is the \texttt{FieldValidateError} 
interface, which is basically a java-bean that only exposes getters in 
\textit{fluent} format. 
%--------1---------2---------3---------4---------5---------6---------7---------8
Please note that some values may be \texttt{null}. A field of type constant has 
no name. A field of type constant or domain or custom with a control set with a 
regular expression does not have a wrong character in a precise column. 
In the error message, if it is possible to identify the character in error, the 
position of the character relative to the field (not to the data-string) is 
shown, the character (if it is a control character the unicode encoding is 
shown), the \textit{name} of the character, and type of error; otherwise the 
value of the field and the type of error are shown.

\begin{elisting}[!htb]
\begin{javacode}
public enum ValidateError {
    NotNumber, NotAscii, NotLatin, NotValid, NotDomain, NotBlank, NotEqual, NotMatch, NotDigitBlank
}
\end{javacode}
\caption{error category \texttt{ValidateError}}
\label{lst:ValidateError:java}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Possible error types are shown in lst.~\ref{lst:ValidateError:java}, the meaning 
is evident from the name.

\subsection{Setters and getters}
%--------1---------2---------3---------4---------5---------6---------7---------8
The data-class implementation used by this library does not actually generate 
deserialized fields. When the class is created from the data-string, the static 
constructor just internally saves the data-string as an array of characters. 
The getter of a field accesses the range of characters corresponding to the 
field and deserializes them on the fly. 
Similarly the setter serializes the supplied value and copies it in the range of 
characters corresponding to the field. 
In this way it is trivial to \textsl{override} a field, the \textit{cast-like} 
constructor and \textit{deep-copy} are almost free of cost. 
The \textsl{encode} and \textsl{decode} methods are also basically free of cost 
because the serialization/deserialization operations are actually performed by 
the setters/getters.

\subsection{Single fields}
\subsubsection*{\texttt{null} value handling}
%--------1---------2---------3---------4---------5---------6---------7---------8
A null value cannot be represented in a data-string, unless conventionally this 
value is assigned to a particular string, as in fields of the numeric-nullable 
type. 
When a setter formally sets the \texttt{null} value, in the data-string 
representation it will actually be assigned the default value of the field: 
space for an alphanumeric type, zero for a numeric type, the \texttt{initChar} 
for a custom type, and the first value between those defined as possible for a 
domain field.

\begin{elisting}[!htb]
\begin{javacode}
    String getValue() { /* ... */ }   // string getter
    int intValue() { /* ... */ }      // int getter
\end{javacode}
\caption{Access to numeric values such as strings and primitive numbers}
\label{lst:num.acc.both}
\end{elisting}

\subsubsection*{\texttt{Both} access for numeric fields}
%--------1---------2---------3---------4---------5---------6---------7---------8
Numeric fields can be handled as strings of numeric characters or as primitive 
numeric objects. Fields can be configured to have getters/setters of type string 
or primitive numeric or both. 
If ``both'' is chosen, it is not possible to define the getter with the 
canonical name for both types. 
In this case the canonical name is used for the getter of type string, 
the getter with the primitive type has as its name the primitive type and the 
field name, see~\ref{lst:num.acc.both}.

\begin{elisting}[!htb]
\begin{quote}
\begin{minted}[frame=single,framesep=2mm,bgcolor=bg,fontsize=\footnotesize,linenos,firstnumber=200]{java}
    @Test
    void testDomain() {
        BarDom dom = new BarDom();
        dom.setCur("AAA");
    }
\end{minted}
\end{quote}
\vspace*{-1cm}
\begin{javacode}
io.github.epi155.recfm.java.NotDomainException: com.example.BarDom.setCur, offending value "AAA"
	at com.example.test.TestBar.testDomain(TestBar.java:203)
	...
\end{javacode}
\caption{Exception on the setter}
\label{lst:set.throw}
\end{elisting}

\subsubsection*{Controls on setters and getters}
%--------1---------2---------3---------4---------5---------6---------7---------8
If the checks on the setters are active and an illegal value is set, an 
exception is thrown which signals the violation of the check. The exception 
places the stacktrace on the setter instruction.

\begin{elisting}[!htb]
\begin{quote}
\begin{minted}[frame=single,framesep=2mm,bgcolor=bg,fontsize=\footnotesize,linenos,firstnumber=300]{java}
    @Test
    void testDomain() {
        BarDom d1 = BarDom.decode("AAA");
        String cur = d1.getCur();
    }
\end{minted}
\end{quote}
\vspace*{-1cm}
\begin{javacode}
io.github.epi155.recfm.java.NotDomainException: com.example.BarDom.getCur, offending value "AAA" @1+3
	at com.example.test.TestBar.testDomain(TestBar.java:303)
	...
\end{javacode}
\caption{Exception on the getter}
\label{lst:get.throw}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
Similarly on getters. If the data-string contains an invalid value for the field 
in the area corresponding to a field, the validation of the structure, which 
would have signaled the problem, is not performed, and the code continues until 
the getter, an exception is thrown. The exception places the stacktrace on the 
getter instruction.

\subsection{Manifold Fields}
%--------1---------2---------3---------4---------5---------6---------7---------8
n this context we will consider repeating fields only those fields of type group 
or repeated group, defined directly or through an interface. 
This type of fields generates an intermediate element. 
As seen from lst.~\ref{lst:grp.indef}, generated for a group defined via an 
interface, an internal class is created to manage the intermediate element, a 
private field with an instance of the intermediate element, a fluent getter of 
the field, and a \textit{Consumer} of the field.

\begin{elisting}[!htb]
\begin{javacode}
    public class StopTime implements Validable, ITime {/* ... */}
    private final StopTime stopTime = this.new StopTime();
    public StopTime stopTime() { return this.stopTime; }
    public void withStopTime(WithAction<StopTime> action) { action.accept(this.stopTime); }
\end{javacode}
\caption{Implementation of a group inside the data-class}
\label{lst:grp.indef}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The inner class will implement the validation interface, and, if defined via 
interface, the interface with the detail definition of the fields of the inner 
class. Each group can be validated individually as if it were a data-class.
The validation interface, \texttt{Validable}, requires the 
\texttt{validateFails} and \texttt{validateAllFails} method that we have already 
encountered in data-class validation. 
All data-classes also implement the \texttt{Validable} interface.

\begin{elisting}[!htb]
\begin{javacode}
public interface Validable {
    boolean validateFails(FieldValidateHandler handler);
    boolean validateAllFails(FieldValidateHandler handler);
}
\end{javacode}
\caption{Validation interface, at class-data and group level}
\label{lst:if.validable}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Defining a repeating group is similar to defining a group. An inner class is 
created to handle the repeating intermediate element, a private field with $n$ 
instances of the intermediate element, a fluent getter with an index of the 
field, and a \textit{Consumer} with index of the field.

\begin{elisting}[!htb]
\begin{javacode}
    public class TabError implements Validable, IError {/* ... */}
    private final TabError[] tabError = new TabError[] {
        this.new TabError(0),
        /* ... */
    };
    public TabError tabError(int k) { return this.tabError[k-1]; }
    public void withTabError(int k, WithAction<TabError> action) { action.accept(this.tabError[k-1]); }
\end{javacode}
\caption{Implementation of a repeating group inside the data-class}
\label{lst:occ.indef}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Also in this case the inner class that defines the intermediate element 
implements the validation interface, and, if defined through an interface, the 
interface with the definition of the detail of the fields of the inner class.


\clearpage
\listoffigures
\listoftables
\listoflistings
\printindex

\end{document}
