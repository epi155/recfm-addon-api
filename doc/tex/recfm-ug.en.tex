\documentclass[a4paper,10pt]{report}

\usepackage[english]{babel}     % sillabazione italiana
\usepackage[body={17.8cm,24.7cm}]{geometry}

\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{pifont}
\usepackage{array,multirow}

\usepackage{makeidx}
\usepackage{tocloft}
\usepackage{fbox}

\usepackage{eflowchart}	% custom style

\newif\ifesource
%\esourcetrue
\ifesource
\usepackage{esourcecode}	% custom style
\else
\usepackage{xcolor,colortbl}
%\usepackage[outputdir={/tmp}]{minted}
\usepackage{minted}
\definecolor{bg}{rgb}{0.95,0.95,0.92}
\usepackage{caption}
\newenvironment{elisting}[1][H]
%  {\captionsetup{aboveskip=-0.1\normalbaselineskip}\begin{listing}[#1]}
  {\captionsetup{aboveskip=0pt}\begin{listing}[#1]}
  {\end{listing}%
}
\newminted{java}{
  frame=single,
  framesep=2mm,
  bgcolor=bg,
  fontsize=\footnotesize,
  escapeinside=||,
    tabsize=4,
%    fontfamily=courier,
    autogobble,
%    xleftmargin=5pt,
%    xrightmargin=5pt,
%    frame=lines,
}
\newminted{yaml}{
  frame=single,
  framesep=2mm,
  bgcolor=bg,
  fontsize=\footnotesize,
    tabsize=4,
%    fontfamily=courier,
    autogobble,
%    xleftmargin=5pt,
%    xrightmargin=5pt,
%    frame=lines,
}
\fi
\newminted{xml}{
  frame=single,
  framesep=2mm,
  bgcolor=bg,fontsize=\footnotesize,
  tabsize=4,
  autogobble,
}

%\usepackage[pdftex]{graphicx}

\usepackage[pdftex,
%pdftitle={Graphics and Color with LaTeX},
%pdfauthor={Patrick W Daly},
%pdfsubject={Importing images and use of color in LaTeX},
%pdfkeywords={LaTeX, graphics, color},
pdfpagemode=UseOutlines,
bookmarks,bookmarksopen,
pdfstartview=FitH,
colorlinks,linkcolor=blue,citecolor=blue,
urlcolor=green,
]
{hyperref}
\usepackage[nolink]{qrcode}

\renewcommand{\arraystretch}{1.2}

\usepackage{tikz}
%\usetikzlibrary{shapes,arrows}
%\usetikzlibrary{arrows,shapes,snakes,automata,backgrounds,petri}
\usetikzlibrary{arrows,shapes,decorations,automata,backgrounds,petri}

%\usepackage{bera}
%\usepackage{beraserif}
%\usepackage{berasans}
%\usepackage[scaled=0.9]{beramono}
\usepackage{newcent}
\usepackage[scaled=0.9]{beramono}
%\usepackage{bookman}
%\usepackage{dejavu}
%\usepackage{roboto}

\title{RECFM}
%\author{E.~Pistolesi}
%\author{\qrcode{Enrico Pistolesi}}

\makeindex
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}	% default is 2

\cftsetindents{section}{0.5in}{0.5in}
\cftsetindents{subsection}{0.5in}{0.6in}
\cftsetindents{subsubsection}{0.5in}{0.7in}
%\cftsetindents{paragraph}{0.5in}{0.5in}
\cftsetindents{table}{0.25in}{0.5in}

\ifesource
\cftsetindents{listings}{0.25in}{0.5in}
%\renewcommand{\lstlistlistingname}{Elenco dei sorgenti}
\else
%\renewcommand{\listingscaption}{Sorgente}
%\renewcommand{\listoflistingscaption}{Elenco dei sorgenti}
%\captionsetup[listing]{aboveskip=-50pt,belowskip=-20pt}
\fi


%--- begin - document ---------------------------------------------------------
\begin{document}

\begin{titlepage}
\newlength{\drop}% for my convenience
\drop=0.1\textheight
\centering
\settowidth{\unitlength}{\large\itshape xxxCode generation to handle positional filesxx}
\vspace*{\baselineskip}
\qrcode{Enrico Pistolesi}\\[\baselineskip]
%{\large\scshape E.~Pistolesi}\\[\baselineskip]
\rule{\unitlength}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}
\rule{\unitlength}{0.4pt}\\[\baselineskip]
{\Huge RECFM User Guide}\\[\baselineskip]
{\large\itshape Code generation to handle positional files}\\[0.2\baselineskip]
\rule{\unitlength}{0.4pt}\vspace*{-\baselineskip}\vspace{3.2pt}
\rule{\unitlength}{1.6pt}\\[\baselineskip]
%{\large\scshape drawings by the artist}\par
\vfill
%{\large\scshape the publisher}\\[\baselineskip]
{\small\scshape \today}\par
\vspace*{\drop}
\end{titlepage}


\section*{Introduction}
%--------1---------2---------3---------4---------5---------6---------7---------8
Sometimes it may happen that you have to deal with positional files (or memory 
areas), see fig.~\ref{fig:str.data}, in these cases you need to waste a lot of 
time to make a class dedicated to each string-data with the setters and getters
to read and write values\footnote{%
there is \texttt{com.ancientprogramming.fixedformat4j:fixedformat4j:1.2.2} 
which provides some basic functionality, but in most situations it is not 
flexible enough.}.

\begin{figure}[!htb]
\centering\small
\scalebox{0.7}[1]{
\texttt{%
\fbox[lb]{S}%01
\fbox[lb]{C}%02
\fbox[lb]{A}%03
\fbox[lb]{R}%04
\fbox[lb]{L}%05
\fbox[lb]{E}%06
\fbox[lb]{T}%07
\fbox[lb]{T}%08
\fbox[lb]{ }%09
\fbox[lb]{ }%10
\fbox[lb]{ }%11
\fbox[lb]{ }%12
\fbox[lb]{ }%13
\fbox[lb]{ }%14
\fbox[lb]{ }%15
\fbox[lb]{J}%16
\fbox[lb]{O}%17
\fbox[lb]{H}%18
\fbox[lb]{A}%19
\fbox[lb]{N}%20
\fbox[lb]{S}%21
\fbox[lb]{S}%22
\fbox[lb]{O}%23
\fbox[lb]{N}%24
\fbox[lb]{ }%25
\fbox[lb]{ }%26
\fbox[lb]{ }%27
\fbox[lb]{ }%28
\fbox[lb]{ }%29
\fbox[lb]{ }%30
\fbox[lb]{1}%31
\fbox[lb]{9}%32
\fbox[lb]{8}%33
\fbox[lb]{4}%34
\fbox[lb]{1}%35
\fbox[lb]{1}%36
\fbox[lb]{2}%37
\fbox[lb]{2}%38
\fbox[lb]{N}%39
\fbox[lb]{E}%40
\fbox[lb]{W}%31
\fbox[lb]{ }%32
\fbox[lb]{Y}%33
\fbox[lb]{O}%34
\fbox[lb]{R}%35
\fbox[lb]{K}%36
\fbox[lb]{ }%37
\fbox[lb]{ }%38
\fbox[lb]{ }%39
\fbox[lb]{ }%40
\fbox[lb]{ }%41
\fbox[lb]{ }%42
\fbox[lb]{U}%43
\fbox[lb]{S}%44
\fbox[lbr]{A}%45
}}


\scalebox{0.7}[1]{
\texttt{%
\fbox[lb]{O}%01
\fbox[lb]{L}%02
\fbox[lb]{G}%03
\fbox[lb]{A}%04
\fbox[lb]{ }%05
\fbox[lb]{ }%06
\fbox[lb]{ }%07
\fbox[lb]{ }%08
\fbox[lb]{ }%09
\fbox[lb]{ }%10
\fbox[lb]{ }%11
\fbox[lb]{ }%12
\fbox[lb]{ }%13
\fbox[lb]{ }%14
\fbox[lb]{ }%15
\fbox[lb]{K}%16
\fbox[lb]{U}%17
\fbox[lb]{R}%18
\fbox[lb]{Y}%19
\fbox[lb]{L}%20
\fbox[lb]{E}%21
\fbox[lb]{N}%22
\fbox[lb]{K}%23
\fbox[lb]{O}%24
\fbox[lb]{ }%25
\fbox[lb]{ }%26
\fbox[lb]{ }%27
\fbox[lb]{ }%28
\fbox[lb]{ }%29
\fbox[lb]{ }%30
\fbox[lb]{1}%31
\fbox[lb]{9}%32
\fbox[lb]{7}%33
\fbox[lb]{9}%34
\fbox[lb]{1}%35
\fbox[lb]{1}%36
\fbox[lb]{1}%37
\fbox[lb]{4}%38
\fbox[lb]{B}%39
\fbox[lb]{E}%40
\fbox[lb]{R}%31
\fbox[lb]{D}%32
\fbox[lb]{J}%33
\fbox[lb]{A}%34
\fbox[lb]{N}%35
\fbox[lb]{S}%36
\fbox[lb]{'}%37
\fbox[lb]{K}%38
\fbox[lb]{ }%39
\fbox[lb]{ }%40
\fbox[lb]{ }%41
\fbox[lb]{ }%42
\fbox[lb]{U}%43
\fbox[lb]{K}%44
\fbox[lbr]{R}%45
}}

\caption{Positional datafile example} 
\label{fig:str.data}
\end{figure}



%--------1---------2---------3---------4---------5---------6---------7---------8
This group of programs aims to minimize the time to create these classes. 
In practice, the structure of the data-string is defined with a configuration 
file, this is fed to a plugin that generates the corresponding data-class, 
which can be used without anything else user intervention.

%--------1---------2---------3---------4---------5---------6---------7---------8
Programs are structured using service provider interface, see 
fig.~\ref{fig:spi}, we have a plugin, or user program (\textsl{Service}), which 
directly sees the classes defined in the \textsl{Service Provider Interface} and 
retrieves them the implementation using the \textsl{ServiceLoader}, this way it 
doesn't have a specific dependency with one of the the implementations used. 
The \textsl{Service Provider} must implement the classes defined in the 
\textsl{Service Provider Interface}.

\begin{figure}[!htb]
\centering
\begin{tikzpicture}[>=latex,font={\sf}]
\node(u1) at (0,1.5) [manual input,text width=2cm,fill=blue!10]{maven plugin};
\node(u2) at (3,1.5) [manual input,text width=2cm,fill=blue!10]{gradle plugin};
\node(u3) at (6,1.5) [manual input,text width=2cm,fill=blue!10]{custom service};
\node(si) at (3,0.0) [preparation,fill=yellow!20]{addon-api};
\node(a1) at (0,-1.5) [process,text width=1.7cm,fill=green!10]{java addon};
\node(a2) at (3,-1.5) [process,text width=1.7cm,fill=green!10]{scala addon};
\node(a3) at (6,-1.5) [process,text width=1.7cm,fill=green!10]{custom provider};

\node at (9,1.5) {Service};
\node at (9,0.0) {Service Provider Interface};
\node at (9,-1.5) {Service Provider};

\draw[arrow] (u1) -- (si.north);
\draw[arrow] (u2) -- (si.north);
\draw[arrow] (u3) -- (si.north);
\draw[arrow] (a1) -- (si.south);
\draw[arrow] (a2) -- (si.south);
\draw[arrow] (a3) -- (si.south);

\end{tikzpicture}
\caption{Structure service, service-provider-interface, service-provider} 
\label{fig:spi}
\end{figure}

%--------1---------2---------3---------4---------5---------6---------7---------8
If the \verb!maven-plugin! finds the library with the \verb!java-addon! 
implementation running it will generate the sources in java, but if it finds 
the \verb!scala-addon! implementation it will generate the scala sources.

%--------1---------2---------3---------4---------5---------6---------7---------8
The documentation is divided into three parts. In the first, \ref{vol:spi}, a 
detailed description of the classes is given defined in the 
\textsl{service provider interface}, this part is useful for those wishing to 
develop a \textit{custom service} or a \textit{custom provider}. 
If you are only interested in how to generate code starting from config files 
it can be skipped.

%--------1---------2---------3---------4---------5---------6---------7---------8
In the second part, \ref{vol:srv}, a description of two plugins used to generate 
the code is given. In particular how to define the layouts with the 
configuration files and how to activate the plugin.

%--------1---------2---------3---------4---------5---------6---------7---------8
In the third part, \ref{vol:sp}, a description of the \textsl{service provider} 
that generates the java source showing also some additional features of 
generated classes beyond simple setters and getters.

%\input{cover.tex}

\clearpage

\tableofcontents

\clearpage

\part{Service Provider Interface}\label{vol:spi}

%  ___       _             __                
% |_ _|_ __ | |_ ___ _ __ / _| __ _  ___ ___ 
%  | || '_ \| __/ _ \ '__| |_ / _` |/ __/ _ \
%  | || | | | ||  __/ |  |  _| (_| | (_|  __/
% |___|_| |_|\__\___|_|  |_|  \__,_|\___\___|
%                                           

\chapter{Service Provider Interface}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!recfm-addon-api! artifact provides a series of interfaces, some enums 
and java-beans to allow the client module to define the paths. 
The code is compiled so that it is compatible with java 5, but it provides the 
\verb!module-info! to be usable properly even with java 9 and above.

\section{CodeProvider}\index{CodeProvider}
%--------1---------2---------3---------4---------5---------6---------7---------8
The starting point is the \textsl{CodeProvider} interface, retrieved from the 
\textsl{ServiceLoader}, see lst.~\ref{lst:CodeProvider}, this interface
provides the instance of the \textsl{CodeFactory} interface.

\begin{elisting}[!htb]
\begin{javacode}
      ServiceLoader<CodeProvider> loader = ServiceLoader.load(CodeProvider.class);
      CodeProvider codeProvider = loader.iterator().next();
\end{javacode}
\vspace*{-1cm}
\begin{javacode}
public interface CodeProvider {
     |\hyperref[lst:CodeFactory]{CodeFactory}| getInstance();
}
\end{javacode}
\caption{CodeProvider interface and retrieving the CodeProvider from the ServiceLoader}
\label{lst:CodeProvider}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8


\section{CodeFactory}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{CodeFactory} interface, see lst.~\ref{lst:CodeFactory}, provides 
methods for defining all elements of the structure.

\begin{elisting}[!htb]
\begin{javacode}
public interface CodeFactory {
    |\hyperref[lst:ClassModel]{ClassModel}| newClassModel();
    |\hyperref[lst:TraitModel]{TraitModel}| newTraitModel();

    |\hyperref[lst:AbcModel]{AbcModel}| newAbcModel();
    |\hyperref[lst:NumModel]{NumModel}| newNumModel();
    |\hyperref[lst:NuxModel]{NuxModel}| newNuxModel();
    |\hyperref[lst:CusModel]{CusModel}| newCusModel();
    |\hyperref[lst:DomModel]{DomModel}| newDomModel();
    |\hyperref[lst:FilModel]{FilModel}| newFilModel();
    |\hyperref[lst:ValModel]{ValModel}| newValModel();
    |\hyperref[lst:GrpModel]{GrpModel}| newGrpModel();
    |\hyperref[lst:OccModel]{OccModel}| newOccModel();
    |\hyperref[lst:EmbModel]{EmbModel}| newEmbModel();
    |\hyperref[lst:GrpTraitModel]{GrpTraitModel}| newGrpTraitModel();
    |\hyperref[lst:OccTraitModel]{OccTraitModel}| newOccTraitModel();
}
\end{javacode}
\caption{CodeFactory interface}
\label{lst:CodeFactory}\index{CodeFactory}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8

\section{Classes / Interfaces}
%--------1---------2---------3---------4---------5---------6---------7---------8
The first method of the \textsl{CodeFactory} interface supplies the definition 
for a class, see lst.~\ref{lst:ClassModel}, and the second interface method 
\textsl{CodeFactory} provides the definition for an interface, see 
lst.~\ref{lst:TraitModel}.

\begin{elisting}[!htb]
\begin{javacode}
public interface ClassModel {
    void setName(String name);
    void setLength(int length);
    void setOnOverflow(|\hyperref[lst:LoadOverflowAction]{LoadOverflowAction}| onOverflow);
    void setOnUnderflow(|\hyperref[lst:LoadUnderflowAction]{LoadUnderflowAction}| onUnderflow);
    void setDoc(Boolean doc);
    void setFields(List<FieldModel> fields);

    void create(String namespace, |\hyperref[lst:GenerateArgs]{GenerateArgs}| ga, |\hyperref[lst:FieldDefault]{FieldDefault}| defaults);
}
\end{javacode}
\caption{ClassModel interface}
\label{lst:ClassModel}\index{ClassModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Both definitions require the name of the structure, its length, whether to 
generate or not the automatic documentation for the class, the list of fields 
that compose it and make available a method for generating the source code.

\begin{elisting}[!htb]
\begin{javacode}
public interface TraitModel {
    void setName(String name);
    void setLength(int length);
    void setDoc(Boolean doc);
    void setFields(List<FieldModel> fields);

    void create(String namespace, |\hyperref[lst:GenerateArgs]{GenerateArgs}| ga, |\hyperref[lst:FieldDefault]{FieldDefault}| defaults);
}
\end{javacode}
\caption{TraitModel interface}
\label{lst:TraitModel}\index{TraitModel}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The class definition also takes two additional parameters to indicate how to 
behave if the size of the data provided was higher or lower than expected.

%--------1---------2---------3---------4---------5---------6---------7---------8
Before seeing the detail of the definition of the various fields, let's see the 
content of the other two parameters required for source code generation.

\subsection{Global Arguments --- GenerateArgs}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{GenerateArgs} class, see lst.~\ref{lst:GenerateArgs}, allows you to 
define some general parameters, common to all classes generate. 
%--------1---------2---------3---------4---------5---------6---------7---------8
The \texttt{sourceDirectory} parameter indicates the root source directory where
to generate the sources, the three subsequent parameters identify the program 
(or plugin) that provided the definition of the layout, these parameters are 
shown as a comment at the beginning of the generated files.

\begin{elisting}[!htb]
\begin{javacode}
@Builder
public class GenerateArgs {
    @NonNull public final String sourceDirectory;
    public final String group;
    public final String artifact;
    public final String version;
}
\end{javacode}
\caption{GenerateArgs class}
\label{lst:GenerateArgs}\index{GenerateArgs}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8

\subsection{Field Defaults --- FieldDefault}
%--------1---------2---------3---------4---------5---------6---------7---------8
In the definition of classes and fields, some parameters available in their 
definition change necessarily (the name of the field), others are almost always 
the same for the same type of field (such as are valid characters in an 
alphanumeric field).
To simplify the definition of the classes, and related fields, it is possible to
omit the ``slightly variable'' parameters in the definition, however it is 
necessary to indicate which value to use for these parameters when they are 
omitted. 
The \textsl{FieldDefault} class, lst.~\ref{lst:FieldDefault}, provides some 
classes dedicated to set the default of the ``slightly variable'' parameters.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class FieldDefault {
    private |\hyperref[lst:ClsDefault]{ClsDefault}| cls = new ClsDefault();
    private |\hyperref[lst:AbcDefault]{AbcDefault}| abc = new AbcDefault();
    private |\hyperref[lst:NumDefault]{NumDefault}| num = new NumDefault();
    private |\hyperref[lst:NuxDefault]{NuxDefault}| nux = new NuxDefault();
    private |\hyperref[lst:FilDefault]{FilDefault}| fil = new FilDefault();
    private |\hyperref[lst:CusDefault]{CusDefault}| cus = new CusDefault();
}
\end{javacode}
\caption{FieldDefault class}
\label{lst:FieldDefault}\index{FieldDefault}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
The first default concerns the default behavior of the class when it is created 
starting from a structure (string), and this has a dimension different from the 
expected one; if the length of the supplied structure is greater than the 
expected one, it is possible to throw an exception and ignore the excess 
content, if the length of the supplied structure is less than the expected one, 
it is possible to throw an exception or complete the missing part with the 
default values of the missing part.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public static class ClsDefault {
    private |\hyperref[lst:LoadOverflowAction]{LoadOverflowAction}| onOverflow = LoadOverflowAction.Trunc;   // enum {Error, Trunc}
    private |\hyperref[lst:LoadUnderflowAction]{LoadUnderflowAction}| onUnderflow = LoadUnderflowAction.Pad;  // enum {Error, Pad}
    private boolean doc = true;
}
\end{javacode}
\caption{ClsDefault class}\index{ClsDefault}
\label{lst:ClsDefault}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8

%--------1---------2---------3---------4---------5---------6---------7---------8
The other defaults allow you to set the default values of some parameters for 
five types of fields. Not having shown the details of the definition of the 
various types of field, it is not appropriate to introduce the content of the 
default classes at this point, they will be shown together with the 
corresponding field.

\chapter{Definition of single fields}
%--------1---------2---------3---------4---------5---------6---------7---------8
In the definition of the class, and of the interface, the list of fields is set 
as \verb!List<FieldModel>!, but the \verb!FieldModel! interface is an empty box, 
it is only used to connect all the field definitions to it.
In general all fields have an initial position (offset) and a dimension 
(length); many fields are referable by a name, but not all are necessarily 
named; when the fields have a name they can be primary or over-define (override) 
primary fields, in the initialization phase of the fields of a class only 
primary field definitions are considered.

%--------1---------2---------3---------4---------5---------6---------7---------8
In the field definitions, the initial position of the field (offset) is set as 
an \texttt{Integer}, ie in general it is not mandatory to set it, it can be 
calculated automatically by the \textsl{Service Provider}.

\section{Alphanumeric field}
%--------1---------2---------3---------4---------5---------6---------7---------8
An alphanumeric field has 4 basic parameters: \verb!offset!, \verb!length!, 
\verb!name! and \verb!override!.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!onOverflow! and \verb!onUnderflow! parameters indicate how the setter 
should behave when a value with a size greater or less than that foreseen for 
that field is supplied. 
The \hypertarget{abc:ovf}{\texttt{onOverflow}} parameter can assume the values 
\verb!Error! and \verb!Trunc!, in the first case the code is expected to 
generate an exception, in the second case the value is found (on the right) 
ignoring the characters in excess of the expected size. 
The \hypertarget{abc:unf}{\texttt{onUnderflow}} parameter can assume the values 
\verb!Error! and \verb!Pad!, in the first case the code is expected to generate 
an exception, in the second case spaces are added (on the right) to reach the 
expected size.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \hypertarget{abc:chk}{\texttt{check}} parameter allows you to specify checks 
to restrict the set of characters allowed for the value. This control is 
activated during the validation of the data string, calling the setters and 
getters. 
Possible values are \verb!None!, \verb!Ascii!, \verb!Latin1!, \verb!Valid!, in 
the first case no check is done, in the second case only ASCII characters are 
accepted, in the third case only ISO-8859-1\footnote{%
more precisely the unicode characters from \texttt{\textbackslash u0020} to 
\texttt{\textbackslash u007e} and from \texttt{\textbackslash u00a0} to 
\texttt{\textbackslash u00ff}
} characters are accepted, and in the last case valid UTF-8 characters are 
accepted.

\begin{elisting}[!htb]
\begin{javacode}
public interface AbcModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);

    void setOverride(boolean override);

    void setOnOverflow(|\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow);
    void setOnUnderflow(|\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow);
    void setCheck(|\hyperref[lst:CheckAbc]{CheckAbc}| check);
    void setNormalize(|\hyperref[lst:NormalizeAbcMode]{NormalizeAbcMode}| normalize);
    void setCheckGetter(Boolean checkGetter);
    void setCheckSetter(Boolean checkSetter);
}
\end{javacode}
\caption{interface AbcModel (alphanumeric field)}
\label{lst:AbcModel}\index{AbcModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The \hypertarget{abc:nrm}{\texttt{normalize}} parameter allows you to indicate 
how to normalize the value of the field in the getter phase. 
The \verb!normalize! parameter can take on 3 values \verb!None!, \verb!Trim! 
and \verb!Trim1!. The first value indicates not to perform any modification of 
the data, the second value indicates to remove all spaces on the right until a 
character other than space is found, if the value is composed only of spaces an 
empty string is produced, the last value, similarly to the previous value, 
removes the spaces on the right until a character other than a space is found, 
but if the value is composed only of spaces, it returns a string composed of a 
space.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \hypertarget{abc:get}{\texttt{checkGetter}} parameter indicates whether or 
not to activate the control indicated with the \verb!check! parameter when the 
getter is called; if the data-string is previously validated, this check can be 
deactivated. 
The \hypertarget{abc:set}{\texttt{checkSetter}} parameter indicates whether or 
not to activate the control indicated with the \verb!check! parameter when 
called the setter.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class AbcDefault {
    private |\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow = OverflowAction.Trunc;
    private |\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow = UnderflowAction.Pad;
    private |\hyperref[lst:CheckAbc]{CheckAbc}| check = CheckAbc.Ascii;
    private |\hyperref[lst:NormalizeAbcMode]{NormalizeAbcMode}| normalize = NormalizeAbcMode.None;
    private boolean checkGetter = true;
    private boolean checkSetter = true;
}
\end{javacode}
\caption{class AbcDefault (default campo alfanumerico)}
\label{lst:AbcDefault}\index{AbcDefault}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{AbcDefault} class, see lst.~\ref{lst:AbcDefault}, set the default 
values for the parameters \verb!onOverflow!, \verb!onUnderflow!, \verb!check!, 
\verb!normalize!, \verb!checkGetter!, \verb!checkSetter!, in case they are not 
set by the client.

\section{Numeric field}\label{sec:spi.num}
%--------1---------2---------3---------4---------5---------6---------7---------8
Even a numeric field has 4 basic parameters: \verb!offset!, \verb!length!,
\verb!name! and \verb!override!.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!access! parameter indicates how to generate the setters and getters. 
In the data-string the numeric field has a representation in string format, in 
the generated code it is possible to choose whether the setters and getters 
manage the value as a string (with numeric characters) or to convert 
the data-string fragment, corresponding to the field, into a native numeric 
representation (\verb!byte!, \verb!short!, \verb!int!, \verb!long!) or 
handle both.
%
The \verb!access! parameter can take on the values \verb!String!, \verb!Number! 
and \verb!Both!. In the first case, setters and getters are generated that 
handle the value as a (numeric) string, in the second case as a native numeric, 
and in the last case both are generated (it will be indicated by the provider 
how to distinguish the string getter from the numeric one). 
If an access is used that provides string type setter/getter, it is checked in 
the setter phase that the supplied string is numeric, and in the getter phase 
that the returned string is numeric.

\begin{elisting}[!htb]
\begin{javacode}
public interface NumModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);

    void setOverride(boolean override);

    void setAccess(|\hyperref[lst:AccesMode]{AccesMode}| access);
    void setWordWidth(|\hyperref[lst:WordWidth]{WordWidth}| width);
    void setOnOverflow(|\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow);
    void setOnUnderflow(|\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow);
    void setNormalize(|\hyperref[lst:NormalizeNumMode]{NormalizeNumMode}| normalize);
}
\end{javacode}
\caption{NumModel interface (numeric field)}
\label{lst:NumModel}\index{NumModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!wordWidth! parameter makes sense only if an access mode has been 
chosen that generates numeric setters/getters, it basically indicates the 
minimum size to be used in numeric representations. 
The \verb!wordWidth! parameter can assume the values \verb!Byte!, \verb!Short!, 
\verb!Int! and \verb!Long!, the values correspond to the use of the 
corresponding native types. 
For example, if a numeric field is represented by a 4-character string, it can 
be converted into numeric format as \verb!short!, if the \verb!wordWidth! 
parameter is set to \verb!Int!, \verb!int! type setters/getters are generated; 
if the parameter value had been \verb!Byte! or \verb!Short!, \verb!short!-type 
setters/getters would have been generated.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!onOverflow! and \verb!onUnderflow! parameters indicate how the setter 
should behave when a value larger or smaller than that expected for that field 
is supplied. 
The \verb!onOverflow! parameter can assume the values \verb!Error! and 
\verb!Trunc!, in the first case the code is expected to generate an exception, 
in the second case the value is truncated (on the left) ignoring the digits in 
excess of the expected size. 
The \verb!onUnderflow! parameter can assume the values \verb!Error! and 
\verb!Pad!, in the first case the code is expected to generate an exception, in 
the second case zeros are added (on the left) to reach the expected size.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!normalize! parameter makes sense only if an access mode has been 
chosen that generates string setters/getters, it allows you to indicate how to 
normalize the value of the field in the getter phase. 
The \verb!normalize! parameter can take on 2 values \verb!None! and \verb!Trim!. 
The first value indicates not to perform any modification of the data, the 
other indicates to remove all the zeros on the left until a digit other than 
zero is found, if the value is composed only of zeros a string composed of a 
zero is produced .

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class NumDefault {
    private |\hyperref[lst:AccesMode]{AccesMode}| access = AccesMode.String;
    private |\hyperref[lst:WordWidth]{WordWidth}| wordWidth = WordWidth.Int;
    private |\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow = OverflowAction.Trunc;
    private |\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow = UnderflowAction.Pad;
    private |\hyperref[lst:NormalizeNumMode]{NormalizeNumMode}| normalize = NormalizeNumMode.None;
}
\end{javacode}
\caption{class NumDefault (default numeric field)}
\label{lst:NumDefault}\index{NumDefault}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{NumDefault} class, see lst.~\ref{lst:NumDefault}, sets the default 
values for the \verb!access!, \verb!wordWidth!, \verb!onOverflow!, 
\texttt{onUnder\-flow} and \verb!normalize! parameters if they are not set by the 
client.

\section{Custom field (alphanumeric)}
%--------1---------2---------3---------4---------5---------6---------7---------8
Even a custom field has the 4 basic parameters: \verb!offset!, \verb!length!,
\verb!name! and \verb!override!.

%--------1---------2---------3---------4---------5---------6---------7---------8
A custom field is a generalization of an alphanumeric field, and can be 
configured to emulate a numeric or nullable numeric field. 
The first sensitive parameter to consider is \verb!align!, the parameter 
indicates how the \texttt{onUnderflow = Pad} field must be aligned. 
The parameter can assume 2 values \verb!LFT! and \verb!RGT!, the first value 
indicates that the field must be aligned to the left, the second value must be 
aligned to the right.
The value of this parameter not only affects the \verb!onUnderflow! parameter 
(indicating from which direction the padding characters must be added), but 
also on \verb!onOverflow! (indicating from which direction the excess characters 
must be removed) and \verb!normalize! (indicating from which direction the 
padding characters be removed).

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!padChar! parameter indicates the padding character to add (in case of 
\texttt{onUnderflow = Pad}) or remove (in case of \texttt{normalize = Trim}). 

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!initChar! parameter indicates the character to use to initialize the 
field.

\begin{elisting}[!htb]
\begin{javacode}
public interface CusModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);
    
    void setOverride(boolean override);
    
    void setAlign(|\hyperref[lst:AlignMode]{AlignMode}| align);
    void setPadChar(Character padChar);
    void setInitChar(Character initChar);
    void setCheck(|\hyperref[lst:CheckCus]{CheckCus}| check);
    void setRegex(String regex);
    void setOnOverflow(|\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow);
    void setOnUnderflow(|\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow);
    void setNormalize(|\hyperref[lst:NormalizeAbcMode]{NormalizeAbcMode}| normalize);
    void setCheckGetter(Boolean checkGetter);
    void setCheckSetter(Boolean checkSetter);
}
\end{javacode}
\caption{CusModel interface (custom field)}
\label{lst:CusModel}\index{CusModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
For the \verb!check! parameter the same considerations apply as for the 
corresponding parameter in the \hyperlink{abc:chk}{alphanumeric case}. 
In this case the possible values are \verb!None!, \verb!Ascii!, \verb!Latin1!, 
\verb!Valid!, \verb!Digit! and \verb!DigitOrBlank!. 
The first four values are identical to the alphanumeric case, the \verb!Digit! 
value limits the accepted characters to numeric ones (from 0 to 9), as for a 
numeric field; the \verb!DigitOrBlank! value requires that the characters be 
numeric or all spaces, such as for a nullable numeric field.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \verb!regex! parameter can be valued with a regular expression that must be 
satisfied by the value of the field. If this parameter is present, the 
\verb!check! parameter is ignored.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class CusDefault {
    private |\hyperref[lst:AlignMode]{AlignMode}| align = AlignMode.LFT;
    private char padChar = ' ';
    private char initChar = ' ';
    private |\hyperref[lst:CheckCus]{CheckCus}| check = CheckCus.Ascii;
    private |\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow = OverflowAction.Trunc;
    private |\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow = UnderflowAction.Pad;
    private |\hyperref[lst:NormalizeAbcMode]{NormalizeAbcMode}| normalize = NormalizeAbcMode.None;
    private boolean checkGetter = true;
    private boolean checkSetter = true;
}
\end{javacode}
\caption{class CusDefault (custom field default)}
\label{lst:CusDefault}\index{CusDefault}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
For the parameters 
\hyperlink{abc:unf}{\texttt{onUnderflow}}, 
\hyperlink{abc:nrm}{\texttt{normalize}},
\hyperlink{abc:get}{\texttt{checkGetter}},
\hyperlink{abc:get}{\texttt{checkSetter}}
the same considerations apply as for the corresponding fields in the 
alphanumeric case. Be careful because the action of the \verb!onOverflow!, 
\verb!onUnderflow! and \verb!normalize! parameters also depends on the value of 
the \verb!align! and \verb!initChar! parameters.

%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{CusDefault} class, see lst.~\ref{lst:CusDefault}, sets the default 
values for the \verb!align!, \verb!padChar!, \verb!initChar!, 
\verb!check!, \texttt{onOver\-flow}, \verb!onUnderflow!, \verb!normalize!, 
\verb!checkGetter! and \verb!checkSetter! parameters if they are not set by the 
client.

\section{Nullable numeric field}
%--------1---------2---------3---------4---------5---------6---------7---------8
A nullable numeric field is an extension of an ordinary numeric field. 
The difference is that the space value (all space characters) is allowed in the 
data-string, this value corresponds to the \verb!null! value in the data-class 
field.

\begin{elisting}[!htb]
\begin{javacode}
public interface NuxModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);

    void setOverride(boolean override);

    void setAccess(|\hyperref[lst:AccesMode]{AccesMode}| access);
    void setWordWidth(|\hyperref[lst:WordWidth]{WordWidth}| width);
    void setOnOverflow(|\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow);
    void setOnUnderflow(|\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow);
    void setNormalize(|\hyperref[lst:NormalizeNumMode]{NormalizeNumMode}| normalize);
    void setInitialize(|\hyperref[lst:InitializeNuxMode]{InitializeNuxMode}| initialize);
}
\end{javacode}
\caption{NuxModel interface (nullable numeric field)}
\label{lst:NuxModel}\index{NuxModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
As can be seen from the definition, lst.~\ref{lst:NuxModel} there are the same 
parameters of a numeric field (lst.~\ref{lst:NumModel}), with the same meanings, 
plus one: the \verb!initialize! parameter. 
This parameter indicates how to initialize the field when the class is created 
with an empty constructor, with the value spaces (i.e. \verb!null!) or zero.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class NuxDefault {
    private |\hyperref[lst:AccesMode]{AccesMode}| access = AccesMode.String;
    private |\hyperref[lst:WordWidth]{WordWidth}| wordWidth = WordWidth.Int;
    private |\hyperref[lst:OverflowAction]{OverflowAction}| onOverflow = OverflowAction.Trunc;
    private |\hyperref[lst:UnderflowAction]{UnderflowAction}| onUnderflow = UnderflowAction.Pad;
    private |\hyperref[lst:NormalizeNumMode]{NormalizeNumMode}| normalize = NormalizeNumMode.None;
    private |\hyperref[lst:InitializeNuxMode]{InitializeNuxMode}| initialize = InitializeNuxMode.Spaces;
}
\end{javacode}
\caption{NuxDefault (default nullable numeric field)}
\label{lst:NuxDefault}\index{NuxDefault}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
To manage the default at a general level for this type of field, a dedicated 
default class is used, which is the copy of the corresponding one for the 
ordinary numeric case, plus the initialization default.

\section{Domain field}
%--------1---------2---------3---------4---------5---------6---------7---------8
A domain-type field is an alphanumeric field that can only assume predefined 
constant values. 
The domain type field, lst.~\ref{lst:DomModel}, has the 4 basic parameters: 
\verb!offset!, \verb!length!, \verb!name! and \verb!override!, plus the 
\verb!items! parameter which will have to provide the list of allowed constant 
values.

\begin{elisting}[!htb]
\begin{javacode}
public interface DomModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);
    
    void setOverride(boolean override);
    
    void setItems(String[] items);
}
\end{javacode}
\caption{DomModel interface (domain field)}
\label{lst:DomModel}\index{DomModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
For this type of field, no global default makes sense as seen for alphanumeric 
and numeric fields. The allowed values are those supplied in the \verb!items! 
parameter, any other value will cause an exception.

\section{Filler field}
%--------1---------2---------3---------4---------5---------6---------7---------8
A field of type \textsl{Filler} is not a real field, has no associated name, 
does not generate any setter or getter in the data-class, and no control 
methods. It is a way to indicate that in the data-string there is an area to 
which no value is associated, or that we are not interested in that area of 
the data-string.

\begin{elisting}[!htb]
\begin{javacode}
public interface FilModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    
    void setFill(Character fill);
}
\end{javacode}
\caption{FilModel interface (filler field)}
\label{lst:FilModel}\index{FilModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The filler field has only the 2 basic parameters: \verb!offset! and 
\verb!length!. It then has the \verb!fill! parameter to indicate with which 
character to value the field when the data-class is created with the empty 
constructor.

\begin{elisting}[!htb]
\begin{javacode}
@Data
public class FilDefault {
    private char fill = 0;
}
\end{javacode}
\caption{class FilDefault (default filler field)}
\label{lst:FilDefault}\index{FilDefault}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The filler field has a default class dedicated to indicate the filler character 
at a general level.

\section{Field Constant value}
%--------1---------2---------3---------4---------5---------6---------7---------8
A field of type \textsl{Constant} is similar to a filler field. As for the 
filler field, setters and getters are not generated in the data-class, but in 
the validation of the data-string it is verified that the area corresponding to 
the field has the indicated constant value.

\begin{elisting}[!htb]
\begin{javacode}
public interface ValModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    
    void setValue(String value);
}
\end{javacode}
\caption{ValModel interface (constant range)}
\label{lst:ValModel}\index{ValModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Even the constant field has only the 2 basic parameters: \verb!offset! and 
\verb!length!. It then has the \verb!value! parameter to indicate the expected 
constant value. The supplied value is used to set the value when the data-class 
is instantiated with the empty constructor.


\chapter{Definition of a group of fields}
%--------1---------2---------3---------4---------5---------6---------7---------8
In some cases it may be useful to group some fields within a container element. 
This allows you to have within the definition of the string-data structure two 
fields with the same name within different container elements.

\section{Field group}
%--------1---------2---------3---------4---------5---------6---------7---------8
A field of type \textsl{Group} is not a real field, it is actually a container 
of other fields.

\begin{elisting}[!htb]
\begin{javacode}
public interface GrpModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);
    
    void setOverride(boolean override);
    
    void setFields(List<FieldModel> fields);
}
\end{javacode}
\caption{interfaccia GrpModel (campo gruppo)}
\label{lst:GrpModel}\index{GrpModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
A group field has 4 basic parameters: \verb!offset!, \verb!length!, \verb!name! 
and \verb!override!. 
In addition to this, it provides the \verb!fields! parameter to provide the list 
of child fields. 
The string-data area selected by \verb!offset! and \verb!length! will need to be 
completely defined by the child fields. 
It is possible for a child field to use the same name as a field defined at the 
same level as the parent field.

\section{Repeating field group}
%--------1---------2---------3---------4---------5---------6---------7---------8
A field of type \textsl{Repeating Group} is similar to a group field, except 
that there are $n$ occurrences of the group. 
In addition to the parameters used by the group field, there is the \verb!times! 
parameter, which indicates the number of times the group is repeated.

\begin{elisting}[!htb]
\begin{javacode}
public interface OccModel extends  FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);
    
    void setOverride(boolean override);
    
    void setFields(List<FieldModel> fields);
    void setTimes(int times);
}
\end{javacode}
\caption{OccModel interface (repeating group field)}
\label{lst:OccModel}\index{OccModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
In this case the area of the data-string defined by \verb!offset! and 
\verb!length! is that of the first occurrence of the group. 
The dimension actually used is \verb!length! $\times$ \verb!times!.

\section{Fields embedded via interface}
%--------1---------2---------3---------4---------5---------6---------7---------8
An interface (lst.~\ref{lst:TraitModel}) can be defined in the same way as a 
class (lst.~\ref{lst:ClassModel}). 
The \textsl{Embedded} field is not a real field, it doesn't have a name. 
Used to indicate that a certain area of the data-string must be interpreted with 
the fields defined by the indicated interface.

\begin{elisting}[!htb]
\begin{javacode}
public interface EmbModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    
    void setSource(|\hyperref[lst:TraitModel]{TraitModel}| source);
}
\end{javacode}
\caption{EmbModel interface (embedded field)}
\label{lst:EmbModel}\index{EmbModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
The embedded field has only the 2 basic parameters: \verb!offset! and 
\verb!length!. 
It then has the \verb!source! parameter to indicate which interface to use to 
define the fields. The interface must have the same size (\verb!length!) of the 
embedded field, the initial position of the interface will be translated to 
adapt it to the value indicated by the embedded field. 
The generated class will obviously implement the indicated interface.

\section{Field group defined via interface} 
%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{Group/Interface} field is similar to the embedded field. 
In this case the fields defined by the interface are not incorporated at the 
current level, but a group containing them is defined.

\begin{elisting}[!htb]
\begin{javacode}
public interface GrpTraitModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);
    
    void setOverride(boolean override);
    
    void setTypedef(|\hyperref[lst:TraitModel]{TraitModel}| typedef);
}
\end{javacode}
\caption{GrpTraitModel interface (group/interface field)}
\label{lst:GrpTraitModel}\index{GrpTraitModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
A group/interface field has 4 basic parameters: \verb!offset!, \verb!length!, 
\verb!name! and \verb!override!. It then has the \verb!typedef! parameter to 
indicate which interface to use to define the fields of the group. 
The interface must have the same size (\verb!length!) of the group/interface 
field, the initial position of the interface will be translated to adapt it to 
the value indicated by the group/interface field. 
In this case it is the group that implements the indicated interface.


\section{Repeating field group defined via interface}
%--------1---------2---------3---------4---------5---------6---------7---------8
The \textsl{Repeating Group/Interface} field is similar to the group/interface 
field, except that there are $n$ occurrences of the group. 
In addition to the parameters used by the group/interface field, there is the 
\verb!times! parameter, which indicates the number of times the group is 
repeated.

\begin{elisting}[!htb]
\begin{javacode}
public interface OccTraitModel extends FieldModel {
    void setOffset(Integer offset);
    void setLength(int length);
    void setName(String name);
    
    void setOverride(boolean override);
    
    void setTypedef(|\hyperref[lst:TraitModel]{TraitModel}| typedef);
    void setTimes(int times);
}
\end{javacode}
\caption{interface OccTraitModel (repeating group/interface field)}
\label{lst:OccTraitModel}\index{OccTraitModel}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
As in the case of the repeated group, the area of the data-string defined by 
\verb!offset! and \verb!length! is that of the first occurrence of the group. 
The dimension actually used is \verb!length! $\times$ \verb!times!.

\vspace*{5cm}

\chapter{enum utilizzati}
%--------1---------2---------3---------4---------5---------6---------7---------8
Molte delle classi o interfacce di configurazione hanno dei campi con valori
limitati ad alcuni valori espresse mediante \texttt{enum}.
Vediamoli uno per uno.

\ifesource
\begin{lstlisting}[language=java, 
caption=enum LoadOverflowAction, 
label=lst:LoadOverflowAction]
public enum LoadOverflowAction { Error, Trunc }
\end{lstlisting}\index{LoadOverflowAction}
\else
\begin{elisting}
\begin{javacode}
public enum LoadOverflowAction { Error, Trunc }
\end{javacode}
\caption{enum LoadOverflowAction}\label{lst:LoadOverflowAction}\index{LoadOverflowAction}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,enum \hyperref[lst:LoadOverflowAction]{\texttt{LoadOverflowAction}} è usato 
dalla classe \hyperref[lst:ClassModel]{\texttt{ClassModel}} per indicare come 
comportarsi quando la classe viene deserializzata e la stringa-dati ha una 
dimensione maggiore di quella attesa dalla classe-dati.

\ifesource
\begin{lstlisting}[language=java, 
caption=enum LoadUnderflowAction, 
label=lst:LoadUnderflowAction]
public enum LoadUnderflowAction { Error, Pad }
\end{lstlisting}\index{LoadUnderflowAction}
\else
\begin{elisting}
\begin{javacode}
public enum LoadUnderflowAction { Error, Pad }
\end{javacode}
\caption{enum LoadUnderflowAction}\label{lst:LoadUnderflowAction}\index{LoadUnderflowAction}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,enum \hyperref[lst:LoadUnderflowAction]{\texttt{LoadUnderflowAction}} è 
usato dalla classe \hyperref[lst:ClassModel]{\texttt{ClassModel}} per indicare 
come comportarsi quando la classe viene deserializzata e la stringa-dati ha una 
dimensione inferiore a quella attesa dalla classe-dati.

\ifesource
\begin{lstlisting}[language=java, 
caption=enum CheckAbc, 
label=lst:CheckAbc]
public enum CheckAbc { None, Ascii, Latin1, Valid }
\end{lstlisting}\index{CheckAbc}
\else
\begin{elisting}
\begin{javacode}
public enum CheckAbc { None, Ascii, Latin1, Valid }
\end{javacode}
\caption{enum CheckAbc}\label{lst:CheckAbc}\index{CheckAbc}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,enum \hyperref[lst:CheckAbc]{\texttt{CheckAbc}} è usato dalla classe
\hyperref[lst:AbcModel]{\texttt{AbcModel}} per indicare quali caratteri sono
considerati validi.

\ifesource
\begin{lstlisting}[language=java, 
caption=enum OverflowAction, 
label=lst:OverflowAction]
public enum OverflowAction { Error, Trunc }
\end{lstlisting}\index{OverflowAction}
\else
\begin{elisting}
\begin{javacode}
public enum OverflowAction { Error, Trunc }
\end{javacode}
\caption{enum OverflowAction}\label{lst:OverflowAction}\index{OverflowAction}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,enum \hyperref[lst:OverflowAction]{\texttt{OverflowAction}} è usato dalla 
classi per gestire i campi numerici e alfanumerici 
(\hyperref[lst:AbcModel]{\texttt{AbcModel}},\break
\hyperref[lst:NumModel]{\texttt{NumModel}},
\hyperref[lst:CusModel]{\texttt{CusModel}},
\hyperref[lst:NuxModel]{\texttt{NuxModel}}), per indicare come comportarsi
quando il setter propone un valore che ha una dimensione maggiore di quella
attesa per quel campo.

\ifesource
\begin{lstlisting}[language=java, 
caption=enum UnderflowAction, 
label=lst:UnderflowAction]
public enum UnderflowAction { Error, Pad }
\end{lstlisting}\index{UnderflowAction}
\else
\begin{elisting}
\begin{javacode}
public enum UnderflowAction { Error, Pad }
\end{javacode}
\caption{enum UnderflowAction}\label{lst:UnderflowAction}\index{UnderflowAction}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,enum \hyperref[lst:UnderflowAction]{\texttt{UnderflowAction}} è usato dalla 
classi per gestire i campi numerici e alfanumerici 
(\hyperref[lst:AbcModel]{\texttt{AbcModel}},\break
\hyperref[lst:NumModel]{\texttt{NumModel}},
\hyperref[lst:CusModel]{\texttt{CusModel}},
\hyperref[lst:NuxModel]{\texttt{NuxModel}}), per indicare come comportarsi
quando il setter propone un valore che ha una dimensione inferiore a quella
attesa per quel campo.

\ifesource
\begin{lstlisting}[language=java, 
caption=enum NormalizeAbcMode, 
label=lst:NormalizeAbcMode]
public enum NormalizeAbcMode { None, Trim, Trim1 }
\end{lstlisting}\index{NormalizeAbcMode}
\else
\begin{elisting}
\begin{javacode}
public enum NormalizeAbcMode { None, Trim, Trim1 }
\end{javacode}
\caption{enum NormalizeAbcMode}\label{lst:NormalizeAbcMode}\index{NormalizeAbcMode}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,enum \hyperref[lst:NormalizeAbcMode]{\texttt{NormalizeAbcMode}} è usato 
dalla classi per gestire i campi alfanumerici 
(\hyperref[lst:AbcModel]{\texttt{AbcModel}},
\hyperref[lst:CusModel]{\texttt{CusModel}}), per indicare come normalizzare
il valore restituito dal getter.

\ifesource
\begin{lstlisting}[language=java, 
caption=enum NormalizeNumMode, 
label=lst:NormalizeNumMode]
public enum NormalizeNumMode { None, Trim }
\end{lstlisting}\index{NormalizeNumMode}
\else
\begin{elisting}
\begin{javacode}
public enum NormalizeNumMode { None, Trim }
\end{javacode}
\caption{enum NormalizeNumMode}\label{lst:NormalizeNumMode}\index{NormalizeNumMode}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,enum \hyperref[lst:NormalizeNumMode]{\texttt{NormalizeNumMode}} è usato 
dalla classi per gestire i campi numerici 
(\hyperref[lst:NumModel]{\texttt{NumModel}},
\hyperref[lst:NuxModel]{\texttt{NuxModel}}), per indicare come normalizzare
il valore restituito dal getter.

\ifesource
\begin{lstlisting}[language=java, 
caption=enum WordWidth, 
label=lst:WordWidth]
public enum WordWidth { Byte, Short, Int, Long }
\end{lstlisting}\index{WordWidth}
\else
\begin{elisting}
\begin{javacode}
public enum WordWidth { Byte, Short, Int, Long }
\end{javacode}
\caption{enum WordWidth}\label{lst:WordWidth}\index{WordWidth}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,enum \hyperref[lst:WordWidth]{\texttt{WordWidth}} è usato 
dalla classi per gestire i campi numerici 
(\hyperref[lst:NumModel]{\texttt{NumModel}},
\hyperref[lst:NuxModel]{\texttt{NuxModel}}), per indicare il tipo dato numerico
primitivo di dimensione minima da usare quando vengono creati setter e getter
numerici.

\ifesource
\begin{lstlisting}[language=java, 
caption=enum AccesMode, 
label=lst:AccesMode]
public enum AccesMode { String, Number, Both }
\end{lstlisting}\index{AccesMode}
\else
\begin{elisting}
\begin{javacode}
public enum AccesMode { String, Number, Both }
\end{javacode}
\caption{enum AccesMode}\label{lst:AccesMode}\index{AccesMode}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,enum \hyperref[lst:AccesMode]{\texttt{AccesMode}} è usato 
dalla classi per gestire i campi numerici 
(\hyperref[lst:NumModel]{\texttt{NumModel}},
\hyperref[lst:NuxModel]{\texttt{NuxModel}}), per indicare se creare setter e
getter alfanumerici, numerici o entrambi.


\ifesource
\begin{lstlisting}[language=java, 
caption=enum InitializeNuxMode, 
label=lst:InitializeNuxMode]
public enum InitializeNuxMode { Spaces, Zeroes }
\end{lstlisting}\index{InitializeNuxMode}
\else
\begin{elisting}
\begin{javacode}
public enum InitializeNuxMode { Spaces, Zeroes }
\end{javacode}
\caption{enum InitializeNuxMode}\label{lst:InitializeNuxMode}\index{InitializeNuxMode}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,enum \hyperref[lst:InitializeNuxMode]{\texttt{InitializeNuxMode}} è usato 
dalla classe \hyperref[lst:NuxModel]{\texttt{NuxModel}}, per indicare come 
inizializzare il campo quando la classe-dati viene creata col costruttore senza
argomenti.

\ifesource
\begin{lstlisting}[language=java, 
caption=enum CheckCus, 
label=lst:CheckCus]
public enum CheckCus { None, Ascii, Latin1, Valid, Digit, DigitOrBlank }
\end{lstlisting}\index{CheckCus}
\else
\begin{elisting}
\begin{javacode}
public enum CheckCus { None, Ascii, Latin1, Valid, Digit, DigitOrBlank }
\end{javacode}
\caption{enum CheckCus}\label{lst:CheckCus}\index{CheckCus}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,enum \hyperref[lst:CheckCus]{\texttt{CheckCus}} è usato dalla classe
\hyperref[lst:CusModel]{\texttt{CusModel}} per indicare quali caratteri sono
considerati validi.



\ifesource
\begin{lstlisting}[language=java, 
caption=enum AlignMode, 
label=lst:AlignMode]
public enum AlignMode { LFT, RGT }
\end{lstlisting}\index{AlignMode}
\else
\begin{elisting}
\begin{javacode}
public enum AlignMode { LFT, RGT }
\end{javacode}
\caption{enum AlignMode}\label{lst:AlignMode}\index{AlignMode}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,enum \hyperref[lst:CheckCus]{\texttt{CheckCus}} è usato dalla classe
\hyperref[lst:CusModel]{\texttt{CusModel}} per indicare come allineare il campo.


\vfill

\part{Service}\label{vol:srv}

%  ____                  _          
% / ___|  ___ _ ____   _(_) ___ ___ 
% \___ \ / _ \ '__\ \ / / |/ __/ _ \
%  ___) |  __/ |   \ V /| | (_|  __/
% |____/ \___|_|    \_/ |_|\___\___|
%                                  

\chapter*{Service}
%--------1---------2---------3---------4---------5---------6---------7---------8
La \textsl{Service Provider Interface} fissa semplicemente la struttura 
generale, ma contiene solo interfacce e java-bean.
Il \textsl{Service} è l'\,applicazione che permette all'\,utente di fornire
l'\,input previsto dalla \textsl{Service Provider Interface}.
Per produrre l'\,output, il \textsl{Service} utilizzerà il 
\textsl{ServiceLoader} per cercare nel classpath un \textsl{Service Provider} 
che implementi la \textsl{Service Provider Interface}, e sarà il 
\textsl{Service Provider} a generare l'\,output dall'\,input.

%--------1---------2---------3---------4---------5---------6---------7---------8
Il cuore del \textsl{Service Provider Interface} \verb!recfm-addon-api! è la
interfaccia \textsl{CodeProvider}. L'\,implementazione della interfaccia
viene cercata col meccanismo del ServiceLoader, cod.\ref{lst:getCodeProvider}.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=java, caption=recupero del CodeProvider, 
label=lst:getCodeProvider]
        ServiceLoader<CodeProvider> loader = ServiceLoader.load(CodeProvider.class);
        (*\hyperref[lst:CodeProvider]{CodeProvider}*) codeProvider = loader.iterator().next();
        (*\hyperref[lst:CodeFactory]{CodeFactory}*) factory = codeProvider.getInstance();
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{javacode}
        ServiceLoader<CodeProvider> loader = ServiceLoader.load(CodeProvider.class);
        |\hyperref[lst:CodeProvider]{CodeProvider}| codeProvider = loader.iterator().next();
        |\hyperref[lst:CodeFactory]{CodeFactory}| factory = codeProvider.getInstance();
\end{javacode}
\caption{recupero del CodeProvider}
\label{lst:getCodeProvider}
\end{elisting}
\fi

%--------1---------2---------3---------4---------5---------6---------7---------8
Una volta recuperata una istanza di \textsl{CodeFactory} è possibile creare le
definizioni delle stringhe-dati e generare i sorgenti delle classi-dati.

%--------1---------2---------3---------4---------5---------6---------7---------8
Sono stati sviluppati due \textsl{client}, uno sotto forma di maven plugin 
\verb!recfm-maven-plugin!, e l'\,altro sotto forma di gradle plugin 
\verb!recfm-gradle-plugin!. Il codice in gran parte è identico, cambia solo il 
meccanismo di innesco.

\chapter{Maven plugin}\label{sec:maven}
%--------1---------2---------3---------4---------5---------6---------7---------8
Il maven plugin \verb!recfm-maven-plugin! permette di creare più classi e 
interfacce usando uno più file di configurazione in formato yaml.
Le librerie esterne utilizzate richiedono il java 8, quindi per eseguire questo 
plugin è necessario almeno il java 8.

Il plugin si aspetta come parametri di configurazione
\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=java, caption=parametri impostabili del maven plugin, 
label=lst:maven.conf]
    @Parameter(defaultValue = "${project.build.directory}/generated-sources/recfm",
        property = "maven.recfm.generateDirectory", required = true)
    private File generateDirectory;

    @Parameter(defaultValue = "${project.build.resources[0].directory}",
        property = "maven.recfm.settingsDirectory", required = true)
    private File settingsDirectory;
    
    @Parameter(required = true)
    private String[] settings;

    @Parameter(defaultValue = "true", property = "maven.recfm.addCompileSourceRoot")
    private boolean addCompileSourceRoot = true;

    @Parameter(defaultValue = "false", property = "maven.recfm.addTestCompileSourceRoot")
    private boolean addTestCompileSourceRoot = false;
    
    @Parameter
    private String codeProviderClassName;
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{javacode}
    @Parameter(defaultValue = "${project.build.directory}/generated-sources/recfm",
        property = "maven.recfm.generateDirectory", required = true)
    private File generateDirectory;

    @Parameter(defaultValue = "${project.build.resources[0].directory}",
        property = "maven.recfm.settingsDirectory", required = true)
    private File settingsDirectory;
    
    @Parameter(required = true)
    private String[] settings;

    @Parameter(defaultValue = "true", property = "maven.recfm.addCompileSourceRoot")
    private boolean addCompileSourceRoot = true;

    @Parameter(defaultValue = "false", property = "maven.recfm.addTestCompileSourceRoot")
    private boolean addTestCompileSourceRoot = false;
    
    @Parameter
    private String codeProviderClassName;
\end{javacode}
\caption{parametri impostabili del maven plugin}
\label{lst:maven.conf}
\end{elisting}
\fi

\begin{itemize}
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \index{plugin!generateDirectory}
	Il campo \fcolorbox{black}{yellow!75}{\texttt{generateDirectory}} indica la 
	directory root da utilizzare per la generazione dei sorgenti, viene usato 
	per valorizzare il campo \verb!sourceDirectory! della classe 
	\hyperref[lst:GenerateArgs]{\texttt{GenerateArgs}}, come si vede dalla 
	definizione, se il parametro è omesso viene utilizzata la directory 
	\verb!target/generated-sources/recfm!, 	normalmente può essere lasciato il 
	valore di default.
	Gli altri tre parametri di \texttt{GenerateArgs} sono un identificativo del
	programma \textsl{service} e vengono valorizzati automaticamente.
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \index{plugin!settingsDirectory}
	Il campo \fcolorbox{black}{yellow!75}{\texttt{settingsDirectory}} indica la 
	directory che contiene i file	di configurazione, se il parametro è omesso 
	viene usato il valore \verb!src/main/resources!, normalmente può essere 
	lasciato il valore di default.
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \index{plugin!settings}
	Il campo \fcolorbox{black}{yellow!75}{\texttt{settings}} indica l'elenco dei 
	file di configurazione da utilizzare per generare le classi/interfacce; il 
	parametro deve essere fornito al plugin.
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \index{plugin!addCompileSourceRoot}
	Il campo \fcolorbox{black}{yellow!75}{\texttt{addCompileSourceRoot}} è un 
	campo tecnico, indica a maven che la directory dove sono stati generati i 
	sorgenti deve essere inclusa tra quelle utilizzate per la compilazione 
	principale, se il parametro è omesso viene utilizzato il valore 
	\verb!true!; il valore \verb!true! è opportuno quando viene usata una 
	directory di generazione del codice diversa da \verb!src/main/java!, 
	altrimenti è necessario usare plugin aggiuntivi per aggiungere il nuovo path 
	a quello di compilazione di maven.
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \index{plugin!addTestCompileSourceRoot}
	Il campo \fcolorbox{black}{yellow!75}{\texttt{addTestCompileSourceRoot}} è 
	analogo al campo precedente, ma aggiunge la directory di generazione al path 
	di compilazione dei test, se omesso viene utilizzato il valore \verb!false!, 
	tranne in casi particolari può essere lasciato il valore di default.
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \index{plugin!codeProviderClassName}
	Il campo \fcolorbox{black}{yellow!75}{\texttt{codeProviderClassName}} indica 
	quale è la classe concreata che implementa la \textsl{Service Interface}, se 
	omesso viene utilizzata la ``prima'' implementazione recuperata del 
	\textsl{ServiceLoader}; se in classpath è presente una sola implementazione, 
	non è necessario valorizzare il parametro. 
\end{itemize}
%--------1---------2---------3---------4---------5---------6---------7---------8

%--------1---------2---------3---------4---------5---------6---------7---------8
\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=XML, caption=esempio minimale di esecuzione del 
plugin, label=lst:mvn-xmpl]
<plugin>
    <groupId>io.github.epi155</groupId>
    <artifactId>recfm-maven-plugin</artifactId>
    <version>0.7.0</version>
    <executions>
        <execution>
            <goals>
                <goal>generate</goal>
            </goals>
            <configuration>
                <settings>
                    <setting>foo.yaml</setting>
                    <setting>bar.yaml</setting>
                </settings>
            </configuration>
        </execution>
    </executions>
    <dependencies>
        <dependency>
            <groupId>io.github.epi155</groupId>
            <artifactId>recfm-java-addon</artifactId>
            <version>0.7.0</version>
        </dependency>
    </dependencies>
</plugin>
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{xmlcode}
<plugin>
    <groupId>io.github.epi155</groupId>
    <artifactId>recfm-maven-plugin</artifactId>
    <version>0.7.0</version>
    <executions>
        <execution>
            <goals>
                <goal>generate</goal>
            </goals>
            <configuration>
                <settings>
                    <setting>foo.yaml</setting>
                    <setting>bar.yaml</setting>
                </settings>
            </configuration>
        </execution>
    </executions>
    <dependencies>
        <dependency>
            <groupId>io.github.epi155</groupId>
            <artifactId>recfm-java-addon</artifactId>
            <version>0.7.0</version>
        </dependency>
    </dependencies>
</plugin>
\end{xmlcode}
\caption{esempio minimale di esecuzione del plugin}
\label{lst:mvn-xmpl}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
Un esempio di esecuzione del plugin è mostrato nel cod.~\ref{lst:mvn-xmpl},
il plugin per essere eseguito deve avere come dipendenza una libreria che 
fornisca l'\,implementazione dell'\,inter\-fac\-cia, altrimenti il 
\verb!ServiceLoader! non trova nulla ed il plugin termina in errore.

%--------1---------2---------3---------4---------5---------6---------7---------8
Tutti gli altri parametri sono forniti nei file di configurazione.

\section{Struttura del file di configurazione}
%--------1---------2---------3---------4---------5---------6---------7---------8
Per gestire la configurazione dei tracciati il plugin definisce la classe
\textsl{MasterBook}, vedi cod.~\ref{lst:MasterBook}, è divisa in due componenti,
la prima \texttt{defaults} è semplicemente il java-bean \textsl{FieldDefault}
(vedi~\ref{lst:FieldDefault}) messo a disposizione dalla 
\textsl{Service Provider Interface} per fornire i valori di default dei 
parametri ``poco variabili'' delle classi e dei campi.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=java, caption=classe di configurazione MasterBook, 
label=lst:MasterBook]
@Data
public class MasterBook {
    private (*\hyperref[lst:FieldDefault]{FieldDefault}*) defaults = new FieldDefault();
    private List<(*\hyperref[lst:ClassPackage]{ClassPackage}*)> packages = new ArrayList<>();
}
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{javacode}
@Data
public class MasterBook {
    private |\hyperref[lst:FieldDefault]{FieldDefault}| defaults = new FieldDefault();
    private List<|\hyperref[lst:ClassPackage]{ClassPackage}|> packages = new ArrayList<>();
}
\end{javacode}
\caption{classe di configurazione MasterBook}
\label{lst:MasterBook}
\end{elisting}
\fi

%--------1---------2---------3---------4---------5---------6---------7---------8
Per semplificare la valorizzazione del file di configurazione yaml, viene usata
un funzionalità delle librerie yaml, che permette di definire nomi abbreviati o
alternativi dei parametri e dei valori dei campi di tipo enum.
I dettagli della componenti del campo \texttt{defaults} sarà mostrato insieme al
campo a cui fornisce il default del valore dei parametri.

%--------1---------2---------3---------4---------5---------6---------7---------8

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=java, caption=classe di configurazione ClassPackage, 
label=lst:ClassPackage]
@Data
public class ClassPackage {
    private String name;     // package name
    private List<(*\hyperref[lst:TraitModel]{TraitModel}*)> interfaces = new ArrayList<>();
    private List<(*\hyperref[lst:ClassModel]{ClassModel}*)> classes = new ArrayList<>();
}
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{javacode}
@Data
public class ClassPackage {
    private String name;     // package name
    private List<|\hyperref[lst:TraitModel]{TraitModel}|> interfaces = new ArrayList<>();
    private List<|\hyperref[lst:ClassModel]{ClassModel}|> classes = new ArrayList<>();
}
\end{javacode}
\caption{classe di configurazione ClassPackage}
\label{lst:ClassPackage}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
La seconda componente di \textsl{MasterBook}, \texttt{packages}, è una lista di
\textsl{ClassPackage} (\ref{lst:ClassPackage}), cioè di package all'\,in\-ter\-no
dei quali vengono definiti un elenco di interfacce e classi.
Espandendo un esempio di questo oggetto in formato yaml (con il default 
relativo) abbiamo:

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=yaml, 
caption={configurazione, area packages / interfaces / classes}, 
label=lst:pakg-conf]
defaults:
  cls:
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    doc: true
packages:
  - name: com.example.test  # package name
    interfaces:
      - &IFoo         (*\color{purple}{\# interface reference}*)
        name: IFoo    # interface name
        length: 12    # :len: interface length
        fields:
          - ...
    classes:
      - name: Foo           # class name
        length: 10          # :len: class length
        onOverflow: Trunc   # :ovf: Error, Trunc
        onUnderflow: Pad    # :unf: Error, Pad
        fields:
          - ...
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{yamlcode}
defaults:
  cls:
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    doc: true
packages:
  - name: com.example.test  # package name
    interfaces:
      - &IFoo         # interface reference
        name: IFoo    # interface name
        length: 12    # :len: interface length
        fields:
          - ...
    classes:
      - name: Foo           # class name
        length: 10          # :len: class length
        onOverflow: Trunc   # :ovf: Error, Trunc
        onUnderflow: Pad    # :unf: Error, Pad
        fields:
          - ...
\end{yamlcode}
\caption{configurazione, area packages / interfaces / classes}
\label{lst:pakg-conf}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
Nei commenti vengono mostrati gli eventuali nomi alternativi dei campi e 
l'\,elenco dei valori \textsl{enum} permessi.
Se non vengono usate interfacce, il nodo \texttt{interfaces} può essere omesso.
Sia per le classi che le interfacce il nome e la lunghezza del tracciato da 
associare devono essere impostate dall'\,utente, nella definizione della classe
può anche essere impostato il comportamento nel caso che venga fornita in fase
di de-serializzazione una struttura con una dimensione maggiore o minore di 
quella attesa.

\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{interfaces \quad \hyperref[lst:TraitModel]{TraitModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&name     &     & String  & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\hline
\hyperref[lst:ClsDefault]{ClsDefault}
&doc        &     & boolean & & \texttt{\$\{defaults.cls.doc:true\}}\\
\hline \multicolumn{1}{c|}{} 
&fields     &     & array & \ding{52} & \\
\cline{2-6}
\end{tabular}
%--------1---------2---------3---------4---------5---------6---------7---------8
\caption{Attributi impostabili per la definizione di una interfaccia} 
\label{tab:attr.trait}
\end{table}


%--------1---------2---------3---------4---------5---------6---------7---------8
Anche se tutti i tipi di campo hanno una posizione di inizio e una lunghezza,
il dettaglio dei parametri di configurazione varia da campo a campo ed è 
necessario introdurre i parametri di configurazione campo per campo.

\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{classes \quad \hyperref[lst:ClassModel]{ClassModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&name     &     & String  & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\hline
\parbox[t]{15mm}{\multirow{3}{*}{\rotatebox[origin=c]{45}{\hyperref[lst:ClsDefault]{ClsDefault}}}}
%\multirow{3}{*}{\hyperref[lst:ClsDefault]{ClsDefault}}
&onOverflow & ovf & \hyperref[lst:LoadOverflowAction]{enum} & & \texttt{\$\{defaults.cls.onOverflow:Trunc\}}\\
\cline{2-6} 
&onUnderlow & unf & \hyperref[lst:LoadUnderflowAction]{enum} & & \texttt{\$\{defaults.cls.onUnderflow:Pad\}}\\
\cline{2-6} 
&doc        &     & boolean & & \texttt{\$\{defaults.cls.doc:true\}}\\
\hline \multicolumn{1}{c|}{}
&fields     &     & array & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
\end{tabular}
%--------1---------2---------3---------4---------5---------6---------7---------8
\caption{Attributi impostabili per la definizione di una classe} 
\label{tab:attr.class}
\end{table}

%--------1---------2---------3---------4---------5---------6---------7---------8
Per indicare esplicitamente il tipo di campo utilizzato vengono introdotti dei
\textsl{tag} da associare ad ogni campo, nella tabella~\ref{tab:tag.class} sono
mostrati i \textsl{tag} associati a ogni tipo di campo.

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}l|l|}
\hline
\multicolumn{3}{|c|}{Tag definizione campo}\\
\hline
\multicolumn{1}{|c|}{tag} & \multicolumn{1}{c|}{classe} 
	& \multicolumn{1}{c|}{note} \\
\hline
\hline
\hyperref[sub:yaml.abc]{!Abc} & \hyperref[lst:AbcModel]{AbcModel} & campo alfanumerico \\
\hline
\hyperref[sub:yaml.num]{!Num} & \hyperref[lst:NumModel]{NumModel} & campo numerico \\
\hline
\hyperref[sub:yaml.cus]{!Cus} & \hyperref[lst:CusModel]{CusModel} & campo custom \\
\hline
\hyperref[sub:yaml.nux]{!Nux} & \hyperref[lst:NuxModel]{NuxModel} & campo numerico nullabile \\
\hline
\hyperref[sub:yaml.dom]{!Dom} & \hyperref[lst:DomModel]{DomModel} & campo dominio \\
\hline
\hyperref[sub:yaml.fil]{!Fil} & \hyperref[lst:FilModel]{FilModel} & campo filler \\
\hline
\hyperref[sub:yaml.val]{!Val} & \hyperref[lst:ValModel]{ValModel} & campo costante \\
\hline
\hyperref[sub:yaml.grp]{!Grp} & \hyperref[lst:GrpModel]{GrpModel} & gruppo di campi \\
\hline
\hyperref[sub:yaml.occ]{!Occ} & \hyperref[lst:OccModel]{OccModel} & gruppo di campi ripetuti \\
\hline
\hyperref[sub:yaml.emb]{!Emb} & \hyperref[lst:EmbModel]{EmbModel} & campi inclusi da interfaccia \\
\hline
\hyperref[sub:yaml.igrp]{!GRP} & \hyperref[lst:GrpTraitModel]{GrpTraitModel} & gruppo di campi inclusi da interfaccia \\
\hline
\hyperref[sub:yaml.iocc]{!OCC} & \hyperref[lst:OccTraitModel]{OccTraitModel} & gruppo di campi ripetuti inclusi da interfaccia\\
\hline
\end{tabular}
%--------1---------2---------3---------4---------5---------6---------7---------8
\caption{Tag yaml per la identificazione del campo} 
\label{tab:tag.class}
\end{table}

\begin{quote}
%--------1---------2---------3---------4---------5---------6---------7---------8
Riguardo all'\,offeset dei campi, va segnalato, che alcune caratteristiche non 
dipendono dal \textsl{Service}, ma dal \textsl{Service Provider}:
l'\,offset minimo può essere zero o uno, l'\,impostazione dell'\,offset può
essere obbligatoria, o facoltativa (l'\,offset può essere calcolato 
automaticamente usando l'\,offset e la lunghezza del campo precedente), 
o non permessa.

%--------1---------2---------3---------4---------5---------6---------7---------8
Il \textsl{Service Provider} descritto nella sezione~\ref{sec:java.addon}
utilizza un offset minimo 1 e l'\,impostazione dell'\,offset è facoltativa.
Se si omette l'\,offset in un campo definito con \textsl{override}, si assume 
che  il campo ridefinisce il campo che lo precede nella definizione della 
struttura.
Nella definizione delle interfacce l'\,uso dell'\,offset è opzionale, ma a 
differenza delle classi, che richiedono un offset minimo 1, per le interfacce
può essere usato qualunque valore iniziale, l'\,offset effettivo viene corretto
quando l'\,interfaccia viene applicata alla classe.
\end{quote}


\section{Campi Singoli}

\subsection{Campo Alfanumerico} \label{sub:yaml.abc}
%--------1---------2---------3---------4---------5---------6---------7---------8
La definizione yaml del campo alfanumerico riflette la struttura imposta dalla
service provider interface, vedi~\ref{lst:AbcModel}.
Un campo alfanumerico è specificato indicando il \textsl{tag} 
\fcolorbox{black}{yellow!75}{\texttt{!Abc}}\,, 
un esempio di definizione di campi alfanumerici è mostrato nel 
cod.~\ref{lst:xmplAbc}, nell'\,esempio è mostrato anche il nodo del default
globale per i campi alfanumerici, i valori impostati sono quelli di default
della \textsl{service provider interface}, quindi non è necessario impostare
esplicitamente i parametri se si vuole impostare questi valori.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=yaml, caption={esempio definizione campi alfanumerici}, 
label=lst:xmplAbc]
defaults:
  abc:
    check: Ascii        # :chk: None, Ascii, Latin1, Valid
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    normalize: None     # :nrm: None, Trim, Trim1
    checkGetter: true   # :get:
    checkSetter: true   # :set:
packages:
  - name: com.example.test
    classes:
      - name: Foo3111
        length: 50
        fields:
          - !Abc { name: cognome    , at:   1, len:    25 }
          - !Abc { name: nome       , at:  26, len:    20 }
          - !Abc { name: stCivile   , at:  46, len:     1 }
          - !Abc { name: nazionalita, at:  47, len:     3 }
          - !Abc { name: sesso      , at:  50, len:     1 }
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{yamlcode}
defaults:
  abc:
    check: Ascii        # :chk: None, Ascii, Latin1, Valid
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    normalize: None     # :nrm: None, Trim, Trim1
    checkGetter: true   # :get:
    checkSetter: true   # :set:
packages:
  - name: com.example.test
    classes:
      - name: Foo3111
        length: 55
        fields:
          - !Abc { name: firstName   , at:  1, len: 15 }
          - !Abc { name: lastName    , at: 16, len: 15 }
          - !Num { name: birthDate   , at: 31, len:  8 }
          - !Abc { name: birthPlace  , at: 39, len: 14 }
          - !Abc { name: birthCountry, at: 53, len:  3 }
\end{yamlcode}
\caption{esempio definizione campi alfanumerici}
\label{lst:xmplAbc}
\end{elisting}
\fi

%--------1---------2---------3---------4---------5---------6---------7---------8
Nell'\,esempio, il nodo di default dei campi alfanumerici, è impostato usando
i nomi canonici dei parametri. Il \textit{plugin} usa una funzionalità 
disponibile della libreria per leggere il file yaml, e definisce dei nomi
abbreviati dei parametri, che possono essere utilizzati come alternativa ai
nomi canonici.

\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{\texttt{!Abc}: \hyperref[lst:AbcModel]{AbcModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&offset     & at  & int     & {\color{lightgray}\ding{52}} & auto-calcolato \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&name       &     & String  & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&override   & ovr & boolean & & \texttt{false} \\
\hline
\parbox[t]{2.5mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{\hyperref[lst:AbcDefault]{AbcDefault}}}}
&onOverflow & ovf & \hyperref[lst:OverflowAction]{enum} & & \texttt{\$\{defaults.abc.onOverflow:Trunc\}}\\
\cline{2-6}
&onUnderlow & unf & \hyperref[lst:UnderflowAction]{enum} & & \texttt{\$\{defaults.abc.onUnderflow:Pad\}}\\
\cline{2-6}
&check      & chk & \hyperref[lst:CheckAbc]{enum} & & \texttt{\$\{defaults.abc.check:Ascii\}}\\
\cline{2-6}
&normalize  & nrm & \hyperref[lst:NormalizeAbcMode]{enum} & & \texttt{\$\{defaults.abc.normalize:None\}}\\
\cline{2-6}
&checkGetter & get & boolean & & \texttt{\$\{defaults.abc.checkGetter:true\}}\\
\cline{2-6}
&checkSetter & set & boolean & & \texttt{\$\{defaults.abc.checkSetter:true\}}\\
\hline
\end{tabular}
\caption{Attributi impostabili per un campo alfanumerico} \label{tab:attr.abc}
\end{table}

%--------1---------2---------3---------4---------5---------6---------7---------8
Nella tabella~\ref{tab:attr.abc} sono mostrati tutti gli attributi previsti per 
un campo alfanumerico, i relativi nomi abbreviati, il corrispondente tipo-dati,
se l'\,attributo è obbligatorio o facoltativo, e l'\,eventuale valore di 
default.

\subsection{Campo Numerico} \label{sub:yaml.num}
%--------1---------2---------3---------4---------5---------6---------7---------8
La definizione yaml del campo numerico riflette la struttura imposta dalla
service interface, vedi~\ref{lst:NumModel}
Un campo numerico è specificato indicando il \textsl{tag} 
\fcolorbox{black}{yellow!75}{\texttt{!Num}}\,, 
un esempio di definizione di campi numerici è mostrato nel 
cod.~\ref{lst:xmplNum}, nell'\,esempio è mostrato anche il nodo del default
globale per i campi numerici, i valori impostati sono quelli di default
della \textsl{service provider interface}, quindi non è necessario impostare
esplicitamente i parametri se si vuole impostare questi valori.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=yaml, caption={esempio definizione campi numerici}, 
label=lst:xmplNum]
defaults:
  num:
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    normalize: None     # :nrm: None, Trim
    wordWidth: Int      # :wid: Byte(1,byte), Short(2,short), Int(4,int), Long(8,long)
    access: String      # :acc: String(Str), Numeric(Num), Both(All)
packages:
  - name: com.example.test
    classes:
      - name: Foo3112
        length: 8
        doc: No
        fields:
          - !Num { name: year , at: 1, len: 4 }
          - !Num { name: month, at: 5, len: 2 }
          - !Num { name: mday , at: 7, len: 2 }
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{yamlcode}
defaults:
  num:
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    normalize: None     # :nrm: None, Trim
    wordWidth: Int      # :wid: Byte(1,byte), Short(2,short), Int(4,int), Long(8,long)
    access: String      # :acc: String(Str), Numeric(Num), Both(All)
packages:
  - name: com.example.test
    classes:
      - name: Foo3112
        length: 8
        doc: No
        fields:
          - !Num { name: year , at: 1, len: 4 }
          - !Num { name: month, at: 5, len: 2 }
          - !Num { name: mday , at: 7, len: 2 }
\end{yamlcode}
\caption{esempio definizione campi numerici}
\label{lst:xmplNum}
\end{elisting}
\fi


\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{\texttt{!Num}: \hyperref[lst:NumModel]{NumModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&offset     & at  & int     & {\color{lightgray}\ding{52}} & auto-calcolato \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&name       &     & String  & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&override   & ovr & boolean & & \texttt{false} \\
\hline
\parbox[t]{2.5mm}{\multirow{5}{*}{\rotatebox[origin=c]{90}{\hyperref[lst:NumDefault]{NumDefault}}}}
&onOverflow & ovf & \hyperref[lst:OverflowAction]{enum} & & \texttt{\$\{defaults.num.onOverflow:Trunc\}}\\
\cline{2-6}
&onUnderlow & unf & \hyperref[lst:UnderflowAction]{enum} & & \texttt{\$\{defaults.num.onUnderflow:Pad\}}\\
\cline{2-6}
&access     & acc & \hyperref[lst:AccesMode]{enum} & & \texttt{\$\{defaults.num.access:String\}}\\
\cline{2-6}
&wordWidth  & wid & \hyperref[lst:WordWidth]{enum} & & \texttt{\$\{defaults.num.wordWidth:Int\}}\\
\cline{2-6}
&normalize  & nrm & \hyperref[lst:NormalizeNumMode]{enum} & & \texttt{\$\{defaults.num.normalize:None\}}\\
\hline
\end{tabular}
\caption{Attributi impostabili per un campo numerico} \label{tab:attr.num}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Nella tabella~\ref{tab:attr.num} sono mostrati tutti gli attributi previsti per 
un campo numerico, i relativi nomi abbreviati, il corrispondente tipo-dati,
se l'\,attributo è obbligatorio o facoltativo, e l'\,eventuale valore di 
default.
%--------1---------2---------3---------4---------5---------6---------7---------8
Anche se i parametri \texttt{acccess} e \texttt{wordWidth} sono stati introdotti
nella \S~\ref{sec:spi.num}, ricordo che un campo ``numerico'' può essere 
gestito come una stringa (dove sono ammessi solo caratteri numerici), o 
convertito in un formato numerico nativo, o entrambi. Il parametro 
\texttt{access} indica se creare soltanto i setter/getter stringa, creare 
soltanto i setter/getter numerici o entrambi.
%come mostrato nei commenti nel default del cod.~\ref{lst:xmplNum} i valori
%dell'\,enum \textsl{String, Numeric, Both} possono essere abbreviati nei 
%corrispondenti \textsl{Str, Num, All}.
%--------1---------2---------3---------4---------5---------6---------7---------8
Nel caso che venga utilizzata una rappresentazione numerica nativa, il parametro
\texttt{wordWidth} indica la rappresentazione nativa di dimensione minima da 
usare.
In generale il \textsl{Service Provider} selezionerà la dimensione della
rappresentazione nativa in base alla dimensione della stringa-dati che finirà 
con rappresentare il valore del campo.


\subsection{Campo Custom (alfanumerico)} \label{sub:yaml.cus}
%--------1---------2---------3---------4---------5---------6---------7---------8
La definizione yaml del campo custom/alfanumerico riflette la struttura imposta 
dalla service provider interface, vedi~\ref{lst:CusModel}.
Un campo alfanumerico è specificato indicando il \textsl{tag} 
\fcolorbox{black}{yellow!75}{\texttt{!Cus}}\,, 
un esempio di definizione di campi custom/alfanumerici è mostrato nel 
cod.~\ref{lst:xmplCus}, nell'\,esempio è mostrato anche il nodo del default
globale per i campi custom, i valori impostati sono quelli di default
della \textsl{service provider interface}, quindi non è necessario impostare
esplicitamente i parametri se si vuole impostare questi valori.

%--------1---------2---------3---------4---------5---------6---------7---------8
Un campo custom è una estensione di un campo alfanumerico. Un campo alfanumerico
è necessariamente allineato a sinistra, troncato, trim-ato a destra, pad-dato a
destra con spazi, inizializzato a spazi. In un campo custom è possibile 
scegliere l'\,allineamento del campo, il carattere di  pad-ding e di 
inizializzazione; ha un \texttt{check} esteso rispetto a quello alfanumerico,
infine, l'\,attributo \texttt{regex} può essere usato per validare i valori
ammessi per il campo (al posto di quello definito con \texttt{check}).

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=yaml, caption={esempio definizione campi custom}, 
label=lst:xmplCus]
defaults:
  cus:
    padChar: ' '        # :pad:
    initChar: ' '       # :ini:
    check: Ascii        # :chk: None, Ascii, Latin1, Valid, Digit, DigitOrBlank
    align: LFT          # LFT, RGT
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    normalize: None     # :nrm: None, Trim, Trim1
    checkGetter: true   # :get:
    checkSetter: true   # :set:
packages:
  - name: com.example.test
    classes:
      - name: Foo3113
        length: 8
        doc: No
        fields:
          - !Cus { name: year , at: 1, len: 4 }
          - !Cus { name: month, at: 5, len: 2 }
          - !Cus { name: mday , at: 7, len: 2 }
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{yamlcode}
defaults:
  cus:
    padChar: ' '        # :pad:
    initChar: ' '       # :ini:
    check: Ascii        # :chk: None, Ascii, Latin1, Valid, Digit, DigitOrBlank
    align: LFT          # LFT, RGT
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    normalize: None     # :nrm: None, Trim, Trim1
    checkGetter: true   # :get:
    checkSetter: true   # :set:
packages:
  - name: com.example.test
    classes:
      - name: Foo3113
        length: 8
        doc: No
        fields:
          - !Cus { name: year , at: 1, len: 4 }
          - !Cus { name: month, at: 5, len: 2 }
          - !Cus { name: mday , at: 7, len: 2 }
\end{yamlcode}
\caption{esempio definizione campi custom}
\label{lst:xmplCus}
\end{elisting}
\fi

\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{\texttt{!Cus}: \hyperref[lst:CusModel]{CusModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&offset     & at  & int     & {\color{lightgray}\ding{52}} & auto-calcolato \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&name       &     & String  & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&override   & ovr & boolean & & \texttt{false} \\
\hline
\parbox[t]{2.5mm}{\multirow{9}{*}{\rotatebox[origin=c]{90}{\hyperref[lst:CusDefault]{CusDefault}}}}
&onOverflow & ovf & \hyperref[lst:OverflowAction]{enum} & & \texttt{\$\{defaults.cus.onOverflow:Trunc\}}\\
\cline{2-6}
&onUnderlow & unf & \hyperref[lst:UnderflowAction]{enum} & & \texttt{\$\{defaults.cus.onUnderflow:Pad\}}\\
\cline{2-6}
&padChar    & pad & char    & & \texttt{\$\{defaults.cus.pad:' '\}}\\
\cline{2-6}
&initChar   & ini & char    & & \texttt{\$\{defaults.cus.init:' '\}}\\
\cline{2-6}
&check      & chk & \hyperref[lst:CheckCus]{enum} & & \texttt{\$\{defaults.cus.check:Ascii\}}\\
\cline{2-6}
&align      &     & \hyperref[lst:AlignMode]{enum} & & \texttt{\$\{defaults.cus.align:LFT\}}\\
\cline{2-6}
&normalize  & nrm & \hyperref[lst:NormalizeAbcMode]{enum} & & \texttt{\$\{defaults.cus.normalize:None\}}\\
\cline{2-6}
&checkGetter & get & boolean & & \texttt{\$\{defaults.cus.checkGetter:true\}}\\
\cline{2-6}
&checkSetter & set & boolean & & \texttt{\$\{defaults.cus.checkSetter:true\}}\\
\hline \multicolumn{1}{c|}{}
&regex      &     & String  & & \texttt{null} \\
\cline{2-6}
\end{tabular}
\caption{Attributi impostabili per un campo custom} \label{tab:attr.cus}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Nella tabella~\ref{tab:attr.cus} sono mostrati tutti gli attributi previsti per 
un campo custom/alfanumerico, i relativi nomi abbreviati, il corrispondente 
tipo-dati, se l'\,attributo è obbligatorio o facoltativo, e l'\,eventuale valore 
di default.



\subsection{Campo Numerico nullabile} \label{sub:yaml.nux}
%--------1---------2---------3---------4---------5---------6---------7---------8
La definizione yaml del campo numerico nullabile riflette la struttura imposta 
dalla service interface, vedi~\ref{lst:NuxModel}.
Un campo numerico nullabile è specificato indicando il \textsl{tag} 
\fcolorbox{black}{yellow!75}{\texttt{!Nux}}\,, 
un esempio di definizione di campi numerici nullabili è mostrato nel 
cod.~\ref{lst:xmplNux}, nell'\,esempio è mostrato anche il nodo del default
globale per i campi numerici nullabili, i valori impostati sono quelli di 
default della \textsl{service provider interface}, quindi non è necessario 
impostare esplicitamente i parametri se si vuole impostare questi valori.


\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=yaml, 
caption={esempio definizione campi numerici nullabili}, 
label=lst:xmplNux]
defaults:
  nux:
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    normalize: None     # :nrm: None, Trim
    wordWidth: Int      # :wid: Byte(1,byte), Short(2,short), Int(4,int), Long(8,long)
    access: String      # :acc: String(Str), Numeric(Num), Both(All)
    initialize: Spaces  # :ini: Spaces(Space), Zeroes(Zero)
packages:
  - name: com.example.test
    classes:
      - name: Foo3114
        length: 8
        doc: No
        fields:
          - !Nux { name: year , at: 1, len: 4 }
          - !Nux { name: month, at: 5, len: 2 }
          - !Nux { name: mday , at: 7, len: 2 }
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{yamlcode}
defaults:
  nux:
    onOverflow: Trunc   # :ovf: Error, Trunc
    onUnderflow: Pad    # :unf: Error, Pad
    normalize: None     # :nrm: None, Trim
    wordWidth: Int      # :wid: Byte(1,byte), Short(2,short), Int(4,int), Long(8,long)
    access: String      # :acc: String(Str), Numeric(Num), Both(All)
    initialize: Spaces  # :ini: Spaces(Space), Zeroes(Zero)
packages:
  - name: com.example.test
    classes:
      - name: Foo3114
        length: 8
        doc: No
        fields:
          - !Nux { name: year , at: 1, len: 4 }
          - !Nux { name: month, at: 5, len: 2 }
          - !Nux { name: mday , at: 7, len: 2 }
\end{yamlcode}
\caption{esempio definizione campi numerici nullabili}
\label{lst:xmplNux}
\end{elisting}
\fi

%--------1---------2---------3---------4---------5---------6---------7---------8
Un campo numerico nullabile è una estensione di un campo numerico ordinario,
la differenza è che nella rappresentazione stringa-dati può assumere il valore
spazio (tutti spazi), che corrisponde nella classe dati al valore \texttt{null}.
Conseguentemente nella definizione del campo è presente un parametro aggiuntivo 
per indicare se il campo deve essere inizializzato a \texttt{null} o a zero 
quando la classe-dati viene creata col costruttore vuoto.

\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{\texttt{!Nux}: \hyperref[lst:NuxModel]{NuxModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&offset     & at  & int     & {\color{lightgray}\ding{52}} & auto-calcolato \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&name       &     & String  & \ding{52} & \\
\cline{2-6} \multicolumn{1}{c|}{}
&override   & ovr & boolean & & \texttt{false} \\
\hline
\parbox[t]{2.5mm}{\multirow{6}{*}{\rotatebox[origin=c]{90}{\hyperref[lst:NuxDefault]{NuxDefault}}}}
&onOverflow & ovf & \hyperref[lst:OverflowAction]{enum} & & \texttt{\$\{defaults.nux.onOverflow:Trunc\}}\\
\cline{2-6}
&onUnderlow & unf & \hyperref[lst:UnderflowAction]{enum} & & \texttt{\$\{defaults.nux.onUnderflow:Pad\}}\\
\cline{2-6}
&access     & acc & \hyperref[lst:AccesMode]{enum} & & \texttt{\$\{defaults.nux.access:String\}}\\
\cline{2-6}
&wordWidth  & wid & \hyperref[lst:WordWidth]{enum} & & \texttt{\$\{defaults.nux.wordWidth:Int\}}\\
\cline{2-6}
&normalize  & nrm & \hyperref[lst:NormalizeNumMode]{enum} & & \texttt{\$\{defaults.nux.normalize:None\}}\\
\cline{2-6}
&initialize & ini & \hyperref[lst:InitializeNuxMode]{enum} & & \texttt{\$\{defaults.nux.initialize:Space\}}\\
\hline
\end{tabular}
\caption{Attributi impostabili per un campo numerico nullabile} \label{tab:attr.nux}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Nella tabella~\ref{tab:attr.nux} sono mostrati tutti gli attributi previsti per 
un campo numerico, i relativi nomi abbreviati, il corrispondente tipo-dati,
se l'\,attributo è obbligatorio o facoltativo, e l'\,eventuale valore di 
default.

\subsection{Campo Dominio} \label{sub:yaml.dom}
%--------1---------2---------3---------4---------5---------6---------7---------8
La definizione yaml del campo numerico riflette la struttura imposta dalla
service interface, vedi~\ref{lst:DomModel}.
Un campo dominio è specificato indicando il \textsl{tag} 
\fcolorbox{black}{yellow!75}{\texttt{!Dom}}\,, 
un esempio di definizione di campi dominio è mostrato nel 
cod.~\ref{lst:xmplDom}, questo tipo di campo non ha nessun default globale.


\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=yaml, caption={esempio definizione campi dominio}, 
label=lst:xmplDom]
packages:
  - name: com.example.test
    classes:
      - name: Foo3115
        length: 12
        doc: No
        fields:
          - !Num { name: year , at: 1, len: 4 }
          - !Dom { name: month, at: 5, len: 3, 
                   items: [ Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec ] }
          - !Num { name: mday , at: 8, len: 2 }
          - !Dom { name: wday , at: 10, len: 3, 
                   items: [ Sun, Mon, Tue, Wed, Thu, Fri, Sat ] }
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    classes:
      - name: Foo3115
        length: 12
        doc: No
        fields:
          - !Num { name: year , at: 1, len: 4 }
          - !Dom { name: month, at: 5, len: 3, 
                   items: [ Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec ] }
          - !Num { name: mday , at: 8, len: 2 }
          - !Dom { name: wday , at: 10, len: 3, 
                   items: [ Sun, Mon, Tue, Wed, Thu, Fri, Sat ] }
\end{yamlcode}
\caption{esempio definizione campi dominio}
\label{lst:xmplDom}
\end{elisting}
\fi

%--------1---------2---------3---------4---------5---------6---------7---------8
Un campo dominio è sostanzialmente un campo alfanumerico, che può assumere solo
un limitato numero di valori.

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!Dom}: \hyperref[lst:DomModel]{DomModel}}\\
\hline
\multicolumn{1}{|c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & auto-calcolato \\
\hline
length     & len & int     & \ding{52} & \\
\hline
name       &     & String  & \ding{52} & \\
\hline
override   & ovr & boolean & & \texttt{false} \\
\hline
items      &     & array  & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributi impostabili per un campo dominio} \label{tab:attr.dom}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Nella tabella~\ref{tab:attr.dom} sono mostrati tutti gli attributi previsti per 
un campo dominio, i relativi nomi abbreviati, il corrispondente tipo-dati,
se l'\,attributo è obbligatorio o facoltativo, e l'\,eventuale valore di 
default.
Quando la classe-dati è creata col costruttore vuoto il campo viene 
inizializzato con il primo valore tra quelli forniti della lista dei possibili
valori.



\subsection{Campo Filler} \label{sub:yaml.fil}
%--------1---------2---------3---------4---------5---------6---------7---------8
La definizione yaml del campo numerico riflette la struttura imposta dalla
service interface, vedi~\ref{lst:FilModel}.
Un campo filler è specificato indicando il \textsl{tag} 
\fcolorbox{black}{yellow!75}{\texttt{!Fil}}\,, 
un esempio di definizione di campi filler è mostrato nel 
cod.~\ref{lst:xmplFil}, nell'\,esempio è mostrato anche il nodo del default
globale per i campi filler, il valore impostato è quello di 
default della \textsl{service provider interface}, quindi non è necessario 
impostare esplicitamente il parametro se si vuole impostare questo valore.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=yaml, 
caption={esempio definizione campi filler}, 
label=lst:xmplFil]
defaults:
  fil:
    fill: 0             # \u0000
packages:
  - name: com.example.test
    classes:
      - name: Foo3116
        length: 10
        doc: No
        fields:
          - !Num { at: 1, len: 4, name: year }
          - !Fil { at: 5, len: 1, fill: '-' }
          - !Num { at: 6, len: 2, name: month }
          - !Fil { at: 8, len: 1, fill: '-' }
          - !Num { at: 9, len: 2, name: mday }
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{yamlcode}
defaults:
  fil:
    fill: 0             # \u0000
packages:
  - name: com.example.test
    classes:
      - name: Foo3116
        length: 10
        doc: No
        fields:
          - !Num { at: 1, len: 4, name: year }
          - !Fil { at: 5, len: 1, fill: '-' }
          - !Num { at: 6, len: 2, name: month }
          - !Fil { at: 8, len: 1, fill: '-' }
          - !Num { at: 9, len: 2, name: mday }
\end{yamlcode}
\caption{esempio definizione campi filler}
\label{lst:xmplFil}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
Un campo filler non è un campo vero e proprio, non vengono generati i
setter/getter, non viene fatto nessun controllo sul valore della stringa-dati
corrispondente. Indica semplicemente un'\,area della stringa-dati a cui non 
siamo interessati, ma che deve essere presente nella definizione della 
struttura per non lasciare aree non definite.

\begin{table}[!htb]
\centering
\begin{tabular}{|c|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{5}{c|}{\texttt{!Fil}: \hyperref[lst:FilModel]{FilModel}}\\
\cline{2-6} \multicolumn{1}{c|}{}
&\multicolumn{1}{c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\cline{2-6} \multicolumn{1}{c|}{}
&offset     & at  & int     & {\color{lightgray}\ding{52}} & auto-calcolato \\
\cline{2-6} \multicolumn{1}{c|}{}
&length     & len & int     & \ding{52} & \\
\hline
\hyperref[lst:FilDefault]{FilDefault}
&fill       &     & char    & & \texttt{\$\{defaults.fil.fill:0\}}\\
\hline
\end{tabular}
\caption{Attributi impostabili per un campo filler} \label{tab:attr.fil}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Nella tabella~\ref{tab:attr.fil} sono mostrati tutti gli attributi previsti per 
un campo filler, i relativi nomi abbreviati, il corrispondente tipo-dati,
se l'\,attributo è obbligatorio o facoltativo, e l'\,eventuale valore di 
default.


\subsection{Campo Costante} \label{sub:yaml.val}
%--------1---------2---------3---------4---------5---------6---------7---------8
La definizione yaml del campo numerico riflette la struttura imposta dalla
service interface, vedi~\ref{lst:ValModel}.
Un campo costante è specificato indicando il \textsl{tag} 
\fcolorbox{black}{yellow!75}{\texttt{!Val}}\,, 
un esempio di definizione di campi cotanti è mostrato nel 
cod.~\ref{lst:xmplVal}, questo tipo di campo non prevede default globali.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=yaml, 
caption={esempio definizione campi costanti}, 
label=lst:xmplVal]
packages:
  - name: com.example.test
    classes:
      - name: Foo3117
        length: 10
        fields:
          - !Num { at: 1, len: 4, name: year }
          - !Val { at: 5, len: 1, val: "-" }
          - !Num { at: 6, len: 2, name: month }
          - !Val { at: 8, len: 1, val: "-" }
          - !Num { at: 9, len: 2, name: mday }
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    classes:
      - name: Foo3117
        length: 10
        fields:
          - !Num { at: 1, len: 4, name: year }
          - !Val { at: 5, len: 1, val: "-" }
          - !Num { at: 6, len: 2, name: month }
          - !Val { at: 8, len: 1, val: "-" }
          - !Num { at: 9, len: 2, name: mday }
\end{yamlcode}
\caption{esempio definizione campi costanti}
\label{lst:xmplVal}
\end{elisting}
\fi

%--------1---------2---------3---------4---------5---------6---------7---------8
Un campo costante può essere visto come una variante di un campo filler, o come
un campo dominio con un solo valore. Per questo tipo di campo non vengono 
generati i setter/getter, ma il campo viene controllato per verificare che la
stringa-dati corrispondente al campo abbia il valore atteso.

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!Val}: \hyperref[lst:ValModel]{ValModel}}\\
\hline
\multicolumn{1}{|c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & auto-calcolato \\
\hline
length     & len & int     & \ding{52} & \\
\hline
value      & val & string  & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributi impostabili per un campo costante} \label{tab:attr.val}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Nella tabella~\ref{tab:attr.val} sono mostrati tutti gli attributi previsti per 
un campo costante, i relativi nomi abbreviati, il corrispondente tipo-dati,
se l'\,attributo è obbligatorio o facoltativo, e l'\,eventuale valore di 
default.


\section{Campi multipli}
%--------1---------2---------3---------4---------5---------6---------7---------8
In alcuni casi è utile raggruppare alcuni campi all'\,interno di un elemento
contenitore di contesto. In questo modo è possibile usare lo stesso nome campo
in contesti diversi. Un campo multiplo non ha default globali.

\subsection{Campo Gruppo} \label{sub:yaml.grp}
%--------1---------2---------3---------4---------5---------6---------7---------8
La definizione yaml del campo gruppo riflette la struttura imposta dalla
service interface, vedi~\ref{lst:GrpModel}.
Un campo gruppo è specificato indicando il \textsl{tag} 
\fcolorbox{black}{yellow!75}{\texttt{!Grp}}\,, 
un esempio di definizione di campi cotanti è mostrato nel 
cod.~\ref{lst:xmplGrp}.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=yaml, 
caption={esempio definizione gruppo di campi}, 
label=lst:xmplGrp]
packages:
  - name: com.example.test
    classes:
      - name: Foo3118
        length: 12
        fields:
          - !Grp { name: startTime, at: 1, len: 6, fields: [
            !Num { name: hours  , at: 1, len: 2 }, 
            !Num { name: minutes, at: 3, len: 2 }, 
            !Num { name: seconds, at: 5, len: 2 }
            ] }
          - !Grp { name: stopTime , at: 7, len: 6, fields: [
            !Num { name: hours  , at:  7, len: 2 }, 
            !Num { name: minutes, at:  9, len: 2 }, 
            !Num { name: seconds, at: 11, len: 2 }
            ] }
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    classes:
      - name: Foo3118
        length: 12
        fields:
          - !Grp { name: startTime, at: 1, len: 6, fields: [
            !Num { name: hours  , at: 1, len: 2 }, 
            !Num { name: minutes, at: 3, len: 2 }, 
            !Num { name: seconds, at: 5, len: 2 }
            ] }
          - !Grp { name: stopTime , at: 7, len: 6, fields: [
            !Num { name: hours  , at:  7, len: 2 }, 
            !Num { name: minutes, at:  9, len: 2 }, 
            !Num { name: seconds, at: 11, len: 2 }
            ] }
\end{yamlcode}
\caption{esempio definizione gruppo di campi}
\label{lst:xmplGrp}
\end{elisting}
\fi

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!Grp}: \hyperref[lst:GrpModel]{GrpModel}}\\
\hline
\multicolumn{1}{|c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & auto-calcolato \\
\hline
length     & len & int     & \ding{52} & \\
\hline
name       &     & String  & \ding{52} & \\
\hline
override   & ovr & boolean & & \texttt{false} \\
\hline
fields     &     & array  & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributi impostabili per un gruppo} \label{tab:attr.grp}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Nella tabella~\ref{tab:attr.grp} sono mostrati tutti gli attributi previsti per 
un campo gruppo, i relativi nomi abbreviati, il corrispondente tipo-dati,
se l'\,attributo è obbligatorio o facoltativo, e l'\,eventuale valore di 
default.


\subsection{Campo Gruppo ripetuto} \label{sub:yaml.occ}
%--------1---------2---------3---------4---------5---------6---------7---------8
La definizione yaml del campo gruppo ripetuto riflette la struttura imposta 
dalla service interface, vedi~\ref{lst:OccModel}.
Un campo gruppo ripetuto è specificato indicando il \textsl{tag} 
\fcolorbox{black}{yellow!75}{\texttt{!Occ}}\,, 
un esempio di definizione di campi cotanti è mostrato nel 
cod.~\ref{lst:xmplOcc}.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=yaml, 
caption={esempio definizione gruppo di campi ripetuto}, 
label=lst:xmplOcc]
packages:
  - name: com.example.test
    classes:
      - name: Foo3119
        length: 590
        fields:
          - !Num { name: nmErrors, at: 1, len: 2 }
          - !Occ { name: tabError, at: 3, len: 49, x: 12, fields: [
            !Abc { name: status  , at:  3, len:  5 },
            !Num { name: code    , at:  8, len:  4 },
            !Abc { name: message , at: 12, len: 40 }
          ] }
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    classes:
      - name: Foo3119
        length: 590
        fields:
          - !Num { name: nmErrors, at: 1, len: 2 }
          - !Occ { name: tabError, at: 3, len: 49, x: 12, fields: [
            !Abc { name: status  , at:  3, len:  5 },
            !Num { name: code    , at:  8, len:  4 },
            !Abc { name: message , at: 12, len: 40 }
          ] }
\end{yamlcode}
\caption{esempio definizione gruppo di campi ripetuto}
\label{lst:xmplOcc}
\end{elisting}
\fi

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!Occ}: \hyperref[lst:OccModel]{OccModel}}\\
\hline
\multicolumn{1}{|c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & auto-calcolato \\
\hline
length     & len & int     & \ding{52} & \\
\hline
name       &     & String  & \ding{52} & \\
\hline
override   & ovr & boolean & & \texttt{false} \\
\hline
times      & x   & int     & \ding{52} & \\
\hline
fields     &     & array  & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributi impostabili per un gruppo ripetuto} \label{tab:attr.occ}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Nella tabella~\ref{tab:attr.occ} sono mostrati tutti gli attributi previsti per 
un campo gruppo ripetuto, i relativi nomi abbreviati, il corrispondente 
tipo-dati, se l'\,attributo è obbligatorio o facoltativo, e l'\,eventuale valore 
di default.

\subsection{Campo gruppo incorporato da interfaccia} \label{sub:yaml.emb}
%--------1---------2---------3---------4---------5---------6---------7---------8
La definizione yaml del campo incorporato riflette la struttura imposta dalla
service interface, vedi~\ref{lst:EmbModel}.
Un campo incorporato è specificato indicando il \textsl{tag} 
\fcolorbox{black}{yellow!75}{\texttt{!Emb}}\,, 
un esempio di definizione di campi cotanti è mostrato nel 
cod.~\ref{lst:xmplEmb}.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=yaml, 
caption={esempio definizione di campi inclusi da interfaccia}, 
label=lst:xmplEmp]
packages:
  - name: com.example.test
    interfaces:
      - &Time
        name: ITime
        len: 6
        fields:
          - !Num { name: hours  , len: 2 }
          - !Num { name: minutes, len: 2 }
          - !Num { name: seconds, len: 2 }
    classes:
      - name: Foo311a
        length: 14
        fields:
          - !Num { name: year , at: 1, len: 4 }
          - !Num { name: month, at: 5, len: 2 }
          - !Num { name: mday , at: 7, len: 2 }
          - !Emb { src: *Time , at: 9, len: 6 }
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    interfaces:
      - &Time
        name: ITime
        len: 6
        fields:
          - !Num { name: hours  , len: 2 }
          - !Num { name: minutes, len: 2 }
          - !Num { name: seconds, len: 2 }
    classes:
      - name: Foo311a
        length: 14
        fields:
          - !Num { name: year , at: 1, len: 4 }
          - !Num { name: month, at: 5, len: 2 }
          - !Num { name: mday , at: 7, len: 2 }
          - !Emb { src: *Time , at: 9, len: 6 }
\end{yamlcode}
\caption{esempio definizione gruppo di campi inclusi da interfaccia}
\label{lst:xmplEmb}
\end{elisting}
\fi

%--------1---------2---------3---------4---------5---------6---------7---------8
Un campo gruppo da interfaccia a differenza degli altri campi multipli non 
crea un elemento di contesto esplicito. I campi sono figli della struttura 
corrente, non di un elemento di contesto. Ma, l'\,elemento corrente
implementa l'\,interfaccia, e questo crea un contesto implicito.

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!Emb}: \hyperref[lst:EmbModel]{EmbModel}}\\
\hline
\multicolumn{1}{|c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & auto-calcolato\\
\hline
length     & len & int     & \ding{52} & \\
\hline
source     & src  & interface & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributi impostabili per un elenco di campi importato da una interfaccia}
\label{tab:attr.emb}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Nella tabella~\ref{tab:attr.emb} sono mostrati tutti gli attributi previsti per 
un campo gruppo da interfaccia, i relativi nomi abbreviati, il corrispondente 
tipo-dati, se l'\,attributo è obbligatorio o facoltativo, e l'\,eventuale valore 
di default.


\subsection{Campo Gruppo da interfaccia} \label{sub:yaml.igrp}
%--------1---------2---------3---------4---------5---------6---------7---------8
La definizione yaml del campo gruppo/interfaccia riflette la struttura imposta 
dalla service interface, vedi~\ref{lst:GrpTraitModel}.
Un campo gruppo/interfaccia è specificato indicando il \textsl{tag} 
\fcolorbox{black}{yellow!75}{\texttt{!GRP}}\,, 
un esempio di definizione di campi cotanti è mostrato nel 
cod.~\ref{lst:xmplIGrp}.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=yaml, 
caption={esempio definizione gruppo di campi da interfaccia}, 
label=lst:xmplIGrp]
packages:
  - name: com.example.test
    interfaces:
      - &Time
        name: ITime
        len: 6
        fields:
          - !Num { name: hours  , len: 2 }
          - !Num { name: minutes, len: 2 }
          - !Num { name: seconds, len: 2 }
    classes:
      - name: Foo311b
        length: 12
        fields:
          - !GRP { name: startTime, at: 1, len: 6, as: *Time }
          - !GRP { name: stopTime , at: 7, len: 6, as: *Time }
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    interfaces:
      - &Time
        name: ITime
        len: 6
        fields:
          - !Num { name: hours  , len: 2 }
          - !Num { name: minutes, len: 2 }
          - !Num { name: seconds, len: 2 }
    classes:
      - name: Foo311b
        length: 12
        fields:
          - !GRP { name: startTime, at: 1, len: 6, as: *Time }
          - !GRP { name: stopTime , at: 7, len: 6, as: *Time }
\end{yamlcode}
\caption{esempio definizione gruppo di campi da interfaccia}
\label{lst:xmplIGrp}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
Un campo gruppo/interfaccia è simile al campo gruppo, la differenza è che i
campi del gruppo non sono definiti singolarmente, ma tutti insieme importandoli
dalla interfaccia. Il gruppo implementerà l'\,interfaccia.

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!GRP}: \hyperref[lst:GrpTraitModel]{GrpTraitModel}}\\
\hline
\multicolumn{1}{|c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & auto-calcolato \\
\hline
length     & len & int     & \ding{52} & \\
\hline
name       &     & String  & \ding{52} & \\
\hline
override   & ovr & boolean & & \texttt{false} \\
\hline
typedef    & as  & interface & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributi impostabili per un gruppo da interfaccia} \label{tab:attr.igrp}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Nella tabella~\ref{tab:attr.igrp} sono mostrati tutti gli attributi previsti per 
un campo gruppo da interfaccia, i relativi nomi abbreviati, il corrispondente 
tipo-dati, se l'\,attributo è obbligatorio o facoltativo, e l'\,eventuale valore 
di default.

\subsection{Campo Gruppo ripetuto da interfaccia} \label{sub:yaml.iocc}
%--------1---------2---------3---------4---------5---------6---------7---------8
La definizione yaml del campo gruppo/interfaccia ripetuto riflette la struttura 
imposta dalla service interface, vedi~\ref{lst:OccTraitModel}.
Un campo gruppo/interfaccia ripetuto è specificato indicando il \textsl{tag} 
\fcolorbox{black}{yellow!75}{\texttt{!OCC}}\,, 
un esempio di definizione di campi cotanti è mostrato nel 
cod.~\ref{lst:xmplIOcc}.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=yaml, 
caption={esempio definizione gruppo di campi ripetuto da interfaccia}, 
label=lst:xmplIOcc]
packages:
  - name: com.example.test
    interfaces:
      - &Error
        name: IError
        len: 49
        fields:
          - !Abc { name: status  , at:  1, len:  5 }
          - !Num { name: code    , at:  6, len:  4 }
          - !Abc { name: message , at: 10, len: 40 }
    classes:
      - name: Foo311c
        length: 590
        fields:
          - !Num { name: nmErrors, at: 1, len: 2}
          - !OCC { name: tabError, at: 3, len: 49, x: 12, as: *Error }
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{yamlcode}
packages:
  - name: com.example.test
    interfaces:
      - &Error
        name: IError
        len: 49
        fileds:
          - !Abc { name: status  , at:  1, len:  5}
          - !Num { name: code    , at:  6, len:  4}
          - !Abc { name: message , at: 10, len: 40}
    classes:
      - name: Foo311c
        length: 590
        fields:
          - !Num { name: nmErrors, at: 1, len: 2}
          - !OCC { name: tabError, at: 3, len: 49, x: 12, as: *Error }
\end{yamlcode}
\caption{esempio definizione gruppo di campi ripetuto da interfaccia}
\label{lst:xmplIOcc}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
Un campo gruppo/interfaccia ripetuto è simile al campo gruppo ripetuto, la 
differenza è che i campi del gruppo non sono definiti singolarmente, ma tutti 
insieme importandoli dalla interfaccia. Il gruppo implementerà l'\,interfaccia.

\begin{table}[!htb]
\centering
\begin{tabular}{|>{\tt}l|>{\tt}c|>{\tt}c|c|l|}
\hline
\multicolumn{5}{|c|}{\texttt{!OCC}: \hyperref[lst:OccTraitModel]{OccTraitModel}}\\
\hline
\multicolumn{1}{|c|}{attributo} & \multicolumn{1}{c|}{alt} 
	& \multicolumn{1}{c|}{tipo} & \multicolumn{1}{c|}{O}
	& \multicolumn{1}{c|}{default} \\
\hline
offset     & at  & int     & {\color{lightgray}\ding{52}} & auto-calcolato \\
\hline
length     & len & int     & \ding{52} & \\
\hline
name       &     & String  & \ding{52} & \\
\hline
override   & ovr & boolean & & \texttt{false} \\
\hline
times      & x   & int     & \ding{52} & \\
\hline
typedef    & as  & interface & \ding{52} & \\
\hline
\end{tabular}
\caption{Attributi impostabili per un gruppo ripetuto da interfaccia} 
\label{tab:attr.iocc}
\end{table}
%--------1---------2---------3---------4---------5---------6---------7---------8
Nella tabella~\ref{tab:attr.iocc} sono mostrati tutti gli attributi previsti per 
un campo gruppo ripetuto da interfaccia, i relativi nomi abbreviati, il 
corrispondente tipo-dati, se l'\,attributo è obbligatorio o facoltativo, e 
l'\,eventuale valore di default.

\chapter{Gradle plugin}\label{sec:gradle}
%--------1---------2---------3---------4---------5---------6---------7---------8
Il gradle plugin \verb!recfm-gradle-plugin! permette di creare più classi e 
interfacce usando uno più file di configurazione in formato yaml.
Le librerie esterne utilizzate richiedono il java 8, quindi per eseguire questo 
plugin è necessario almeno il java 8.

%--------1---------2---------3---------4---------5---------6---------7---------8
Il gradle plugin \verb!recfm-gradle-plugin! è semplicemente l'\,adattamento del 
\verb!recfm-gradle-plugin! per essere usato in un progetto \textsl{gradle}.
Se si esclude il modo in cui vengono passati i parametri di input, e come viene
attivato il plugin, il codice è la copia della versione per maven.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=java, caption=parametri impostabili del gradle plugin, 
label=lst:gradle.conf]
@Data
public class RecordFormatExtension {
    private String generateDirectory; // default: "${project.buildDir}/generated-sources/recfm"
    private String settingsDirectory; // default: "${project.projectDir}/src/main/resources"
    private String[] settings;
    private boolean addCompileSourceRoot = true;
    private boolean addTestCompileSourceRoot = false;
    private String codeProviderClassName;
}
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{javacode}
@Data
public class RecordFormatExtension {
    private String generateDirectory; // default: "${project.buildDir}/generated-sources/recfm"
    private String settingsDirectory; // default: "${project.projectDir}/src/main/resources"
    private String[] settings;
    private boolean addCompileSourceRoot = true;
    private boolean addTestCompileSourceRoot = false;
    private String codeProviderClassName;
}
\end{javacode}
\caption{parametri impostabili del gradle plugin}
\label{lst:gradle.conf}
\end{elisting}
\fi
%--------1---------2---------3---------4---------5---------6---------7---------8
Come si vede col confronto del cod.~\ref{lst:maven.conf} i parametri utilizzati
sono gli stessi del maven-plugin, per la descrizione dei parametri rimando
al \S~\ref{sec:maven}.

\begin{elisting}[!htb]
\begin{minted}[frame=single,framesep=2mm,bgcolor=bg,fontsize=\footnotesize]{groovy}
buildscript {
    dependencies {
        // plugin
        classpath 'io.github.epi155:recfm-gradle-plugin:0.7.0'
        // addon for java code generation
        classpath 'io.github.epi155:recfm-java-addon:0.7.0'
    }
}
apply plugin: 'RecordFormatPlugin'
recfm {
    settings  'recfm-foo.yaml'
}
\end{minted}
\caption{esempio minimale di esecuzione del plugin}
\label{lst:grd-xmpl}
\end{elisting}


\part{Service Provider}\label{vol:sp}

\chapter{Service Provider}
%--------1---------2---------3---------4---------5---------6---------7---------8
Nei capitoli precedenti abbiamo visto la \textsl{Service Provider Interface}, 
che  definisce delle interfacce e delle classi che permettono di definire i 
traccciati, e indicare alcuni comportamenti che dovranno essere usati in fase di
utilizzazione dei tracciati; e alcuni esempi di \textsl{Service}, che
semplicemente valorizza gli oggetti messi a disposizione della 
\textsl{Service Provider Interface}, ma il vero lavoro di generazione del codice 
è fatto dal \textsl{Service Provider}.

%--------1---------2---------3---------4---------5---------6---------7---------8
La struttuta SPI consente di avere codice generato diverso, implementato in modo
diverso, o addirittura generare sorgente in un linguaggio diverso.

%--------1---------2---------3---------4---------5---------6---------7---------8
Qualunque sia il linguaggio generato e il dettaglio della implementazione il
\textsl{Service Provider} dovrà fornire alcune funzionalità generali.

\begin{itemize}
%--------1---------2---------3---------4---------5---------6---------7---------8
\item \textbf{decode}: partendo dalla stringa-dati, deve instanziare la 
    classe-dati;
\item \textbf{setter, getter}: la classe-dati generata deve fornire i metodi di 
    accesso ai singoli campi;
\item \textbf{costruttore vuoto}: la classe-dati può essere instanziata con i 
    valori di default dei campi;
\item \textbf{encode}: la classe-dati può essere serializzata nella 
    stringa-dati.
\end{itemize}
%--------1---------2---------3---------4---------5---------6---------7---------8
Sarebbe gradita anche qualche funzionalià accessoria:
\begin{itemize}
\item \textbf{validate}: validare la stringa-dati prima della 
    de-serializzazione, in modo da segnalare tutte le aree che non possono essere
    assegnate ai relativi campi, tipicamente caratteri non numerici in campi di
    tipo numerico;
\item \textbf{cast}: se due stringhe-dati hanno la stessa lunghezza, poter 
    passare da una classe-dati che le rappresenta all'\,altra;
\item \textbf{toString}: fornire un metodo che mostra tutti i valori dei campi 
    che compongono la classe-dati.
\item (deep) \textbf{copy}: genera una copia della classe-dati;
\end{itemize}



\section{Generazione sorgente java --- \texttt{java-addon}} 
\label{sec:java.addon}
%--------1---------2---------3---------4---------5---------6---------7---------8
Le classi generate dal \textsl{CodeProvider} java oltre ai setter e getter
hanno una serie di metodi ausiliari, vedi cod.~\ref{lst:Foo312:java}.


\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=java, caption=esempio di classe generata (Foo312), 
label=lst:Foo312:java]
public class Foo312 extends FixRecord {
    public static final int LRECL = 50;
    public Foo312() { /* ... */ }
    public static Foo312 of(FixRecord r) { /* ... */ }
    public static Foo312 decode(String s) { /* ... */ }
    public Foo312 copy() { /* ... */ }
    // setter and getter ...
    public boolean validateFails((*\hyperref[lst:FieldValidateHandler:java]{FieldValidateHandler}*) handler) { /* ... */ }
    public String toString() { /* ... */ }
    public String encode() { /* ... */ }    // from super class
}
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{javacode}
public class Foo312 extends FixRecord {
    public static final int LRECL = 50;
    public Foo312() { /* ... */ }
    public static Foo312 of(FixRecord r) { /* ... */ }
    public static Foo312 decode(String s) { /* ... */ }
    public Foo312 copy() { /* ... */ }
    // setter and getter ...
    public boolean validateFails(|\hyperref[lst:FieldValidateHandler:java]{FieldValidateHandler}| handler) { /* ... */ }
    public String toString() { /* ... */ }
    public String encode() { /* ... */ }    // from super class
}
\end{javacode}
\caption{esempio di classe generata (Foo312)}
\label{lst:Foo312:java}
\end{elisting}
\fi

%--------1---------2---------3---------4---------5---------6---------7---------8
\begin{itemize}
\item viene messa a disposizione una costante con la lunghezza della 
    stringa-dati attesa
\item viene fornito un costruttore senza argomenti, che crea la classe con i 
    valori a default
\item viene fornito un costruttore \textit{cast-like}, che prende come argomento
    qualunque altra classe che rappresenta una classe-dati
\item viene fornito un costruttore da stringa-dati (de-serializzatore)
\item viene fornito un metodo \textit{deep-copy} per duplicare la classe-dati
\item viene fornito un metodo di validazione
\item viene fornito un metodo di \texttt{toString}
\item viene fornito un metodo per generare la stringa-dati (serializzatore)
\end{itemize}

%--------1---------2---------3---------4---------5---------6---------7---------8
Le classi generate dai file di configurazione ereditano delle classi generali
con metodi comuni per la gestione dei setter/getter dei controlli e le 
validazioni. Queste classi sono fornite come libreria esterna, 
vedi~\ref{lst:mvn-j-deps}.

\begin{elisting}[!htb]
\begin{xmlcode}
<dependencies>
  <dependency>
    <groupId>io.github.epi155</groupId>
    <artifactId>recfm-java-lib</artifactId>
    <version>0.7.0</version>
  </dependency>
</dependencies>
\end{xmlcode}
\caption{dipendenze runtime dell'\,addon-java}
\label{lst:mvn-j-deps}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Queste librerie sono compilate in compatibilità java-5, e contangono il
\textsl{module-info} per poter essere correttamente gestite anche con java-9 e
superiori.

\subsection{Validazione}
%--------1---------2---------3---------4---------5---------6---------7---------8
Come visto nel sorgente~\ref{lst:Foo312:java} per ogni classe viene generato
un metodo di validazione. L'\,argomento è una interfaccia dedicata, ma questo è
per compatibilità pre-java-8.
L'\,argometo sarà una \textit{closure}, implementata con una classe anonima o 
interna o una $\lambda$-function.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=java, 
caption={gestore errori \texttt{FieldValidateHandler}}, 
label=lst:FieldValidateHandler:java]
public interface FieldValidateHandler {
    void error((|hyperref[lst:FieldValidateError:java]{FieldValidateError}| fieldValidateError);
}
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{javacode}
public interface FieldValidateHandler {
    void error(|\hyperref[lst:FieldValidateError:java]{FieldValidateError}| fieldValidateError);
}
\end{javacode}
\caption{gestore errori \texttt{FieldValidateHandler}}
\label{lst:FieldValidateHandler:java}
\end{elisting}
\fi

%--------1---------2---------3---------4---------5---------6---------7---------8
Il metodo \texttt{validateFails} indica se la validzione della stringa-dati
acquisita con il costruttore statico \texttt{decode} ha superato la validazione
richiesta dalla definizione dei campi oppure no, ma ogni volta che viene 
rilevato un errore di validazione viene chiamato il metodo \texttt{error}
dell'\,interfaccia fornita come argomento con i dettagli dell'\,errore.
In questo modo è possibile accumulare tutti gli errori di validazione rilevati.


\begin{elisting}[!htb]
\begin{javacode}
public class FixError {
    public static synchronized void failFirst() { /* ... */ }
    public static synchronized void failAll() { /* ... */ }
    /* ... */
}
\end{javacode}
\caption{Impostazione comportamento in caso di errore multipli sullo stesso campo}
\label{lst:failFirst.failAll}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Nel caso che un campo abbia più caratteri in errore è possibile segnalare solo
il primo carattere in errore, o tutti i caratteri in errore.
La scelta è discrezionale, la classe \texttt{FixError} mette a disposizione due 
metodi per impostare in modo globale questa scelta. Se non viene impostato
esplicitamente viene segnalato solo il primo carattere in errore del campo.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=java, 
caption={dettaglio errore \texttt{FieldValidateError}}, 
label=lst:FieldValidateError:java]
public interface FieldValidateError {
    String name();          // field name in error
    int offset();           // field offset in error
    int length();           // field length in error
    String value();         // field value in error
    Integer column();       // column of the record with the wrong character
    (*\hyperref[lst:ValidateError:java]{ValidateError}*) code();   // error category
    Character wrong();      // wrong character
    String message();       // field message error
}
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{javacode}
public interface FieldValidateError {
    String name();          // field name in error
    int offset();           // field offset in error
    int length();           // field length in error
    String value();         // field value in error
    Integer column();       // column of the record with the wrong character
    |\hyperref[lst:ValidateError:java]{ValidateError}| code();   // error category
    Character wrong();      // wrong character
    String message();       // field message error
}
\end{javacode}
\caption{dettaglio errore \texttt{FieldValidateError}}
\label{lst:FieldValidateError:java}
\end{elisting}
\fi

%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,argomento del metodo \texttt{error} è l'\,interfaccia
\texttt{FieldValidateError}, che sostanzialmente è una java-bean che espone solo
i getter in formato \textit{fluente}.
%--------1---------2---------3---------4---------5---------6---------7---------8
Segnaliamo che alcuni valori possono essere \texttt{null}.
Un campo di tipo costante non ha un nome (\texttt{name}). 
Un campo di tipo costante o dominio o custom con un controllo impostato con 
espressione regolare non ha un carattere sbagliato (\texttt{wrong})
ad una ben precisa colonna (\texttt{column}).
Nel messaggio di errore, se è possibile identificare il carattere in
errore, viene mostrata la posizione del carattere relativa al campo (non alla 
stringa-dati), il carattere (se è un carattere di controllo viene mostrata la
codifica unicode), il \textit{nome} del carattere, e il tipo di errore; 
altrimenti viene mostrato il valore del campo e il tipo di errore.

\ifesource
\begin{figure*}[!htb]
\begin{lstlisting}[language=java, 
caption={categoria errore \texttt{ValidateError}}, 
label=lst:ValidateError:java]
public enum ValidateError {
    NotNumber, NotAscii, NotLatin, NotValid, NotDomain, NotBlank, NotEqual, NotMatch, NotDigitBlank
}
\end{lstlisting}
\end{figure*}
\else
\begin{elisting}[!htb]
\begin{javacode}
public enum ValidateError {
    NotNumber, NotAscii, NotLatin, NotValid, NotDomain, NotBlank, NotEqual, NotMatch, NotDigitBlank
}
\end{javacode}
\caption{categoria errore \texttt{ValidateError}}
\label{lst:ValidateError:java}
\end{elisting}
\fi

%--------1---------2---------3---------4---------5---------6---------7---------8
I possibili tipi di errore sono mostrati nel 
sorgente~\ref{lst:ValidateError:java}, il significato è evidente dal nome.

\subsection{Setter e getter}
%--------1---------2---------3---------4---------5---------6---------7---------8
L'\,implementazione della classe-dati usata da questa libreria, in realtà non 
genera dei campi de-serializzati. 
Quando la classe viene creata dalla stringa-dati, il costruttore statico si 
limita a salvare internamente la stringa-dati come vettore di caratteri. 
Il getter di un campo accede all'\,intervallo di caratteri corrispondenti al 
campo e li de-serializza. 
Analogamente il setter serializza il valore fornito e lo copia 
nell'\,intervallo di caratteri corrispondenti al campo. 
In questo modo è banale fare un \textsl{override} di un campo, e il 
costruttore \textit{cast-like} e \textit{deep-copy} sono quasi a costo zero.
Anche i metodi \textsl{encode} e \textsl{decode} sono sostanzialmente a costo 
zero perché le operazioni di serializzazione/deserializzazione sono in realtà 
eseguite dai setter/getter.

\subsection{Campi Singoli}
\subsubsection*{Gestione valore \texttt{null}}
%--------1---------2---------3---------4---------5---------6---------7---------8
In una stringa-dati non è rappresentabile un valore nullo, a meno che 
convenzionalmente si assegni ad una particolare stringa tale valore, come nei 
campi di tipo numerico-nullabile.
Quando un setter formalmente imposta il valore \texttt{null}, nella 
rappresentazione della stringa-dati in realtà verrà assegnato il valore di
default del campo: spazio per un tipo alfanumerico, zero per un tipo numerico,
lo \texttt{initChar} per un tipo custom, e il primo valore tra quelli definiti 
come possibili per un campo dominio.

\begin{elisting}[!htb]
\begin{javacode}
    String getValue() { /* ... */ }   // string getter
    int intValue() { /* ... */ }      // int getter
\end{javacode}
\caption{Accesso a volori numerici come stringe e numeri primitivi}
\label{lst:num.acc.both}
\end{elisting}

\subsubsection*{Accesso \texttt{Both} per campi numerici}
%--------1---------2---------3---------4---------5---------6---------7---------8
I campi numerici possono essere gestiti come stringhe di caratteri numerici o
come oggetti numerici primitivi. È possibile configurare i campi per avere 
getter/setter di tipo stringa o numerico primitivo o entrambi.
Nel caso venga scelto ``entrambi'' non è possibile definire il getter con il
nome canonico per entrambi i tipi.
In questi casi il nome canonico viene usato per il getter di tipo stringa,
il getter con il tipo primitivo ha come nome il tipo primitivo e il nome del 
campo, vedi~\ref{lst:num.acc.both}.

\begin{elisting}[!htb]
\begin{quote}
\begin{minted}[frame=single,framesep=2mm,bgcolor=bg,fontsize=\footnotesize,linenos,firstnumber=200]{java}
    @Test
    void testDomain() {
        BarDom dom = new BarDom();
        dom.setCur("AAA");
    }
\end{minted}
\end{quote}
\vspace*{-1cm}
\begin{javacode}
io.github.epi155.recfm.java.NotDomainException: com.example.BarDom.setCur, offending value "AAA"
	at com.example.test.TestBar.testDomain(TestBar.java:203)
	...
\end{javacode}
\caption{Eccezione sul setter}
\label{lst:set.throw}
\end{elisting}

\subsubsection*{Controlli sui setter e getter}
%--------1---------2---------3---------4---------5---------6---------7---------8
Se sono attivi i controlli sui setter e viene impostato un valore non permesso 
viene lanciata una eccezione che segnala la violazione del controllo.
L'\,eccezione posiziona lo stacktrace sulla istruzione del setter.

\begin{elisting}[!htb]
\begin{quote}
\begin{minted}[frame=single,framesep=2mm,bgcolor=bg,fontsize=\footnotesize,linenos,firstnumber=300]{java}
    @Test
    void testDomain() {
        BarDom d1 = BarDom.decode("AAA");
        String cur = d1.getCur();
    }
\end{minted}
\end{quote}
\vspace*{-1cm}
\begin{javacode}
io.github.epi155.recfm.java.NotDomainException: com.example.BarDom.getCur, offending value "AAA" @1+3
	at com.example.test.TestBar.testDomain(TestBar.java:303)
	...
\end{javacode}
\caption{Eccezione sul getter}
\label{lst:get.throw}
\end{elisting}
%--------1---------2---------3---------4---------5---------6---------7---------8
Analogamente sui getter. Se la stringa-dati contiene nella zona corrispondente 
a un campo un valore non valido per il campo, non viene fatta la validazione 
della struttura, che avrebbe segnalato il problema, e il codice continua fino 
al getter, viene lanciata una eccezione.
L'\,eccezione posiziona lo stacktrace sulla istruzione del getter.

\subsection{Campi Multipli}
%--------1---------2---------3---------4---------5---------6---------7---------8
In questo contesto considereremo campi multipli solo i campi di tipo gruppo o
gruppo ripetuto, definiti direttamente o tramite interfaccia.
Questo tipo di campi genera un elemento intermedio.
Come si vede dal sorgente~\ref{lst:grp.indef}, generato per un gruppo definito
da interfaccia, viene creata una classe interna per gestire l'\,elemento 
intermedio, un campo privato con una istanza dell'\,elemento intermedio, un
\textit{getter fluente} del campo, e un \textit{Consumer} del campo.

\begin{elisting}[!htb]
\begin{javacode}
    public class StopTime implements Validable, ITime {/* ... */}
    private final StopTime stopTime = this.new StopTime();
    public StopTime stopTime() { return this.stopTime; }
    public void withStopTime(WithAction<StopTime> action) { action.accept(this.stopTime); }
\end{javacode}
\caption{Definizione di un gruppo interno alla classe-dati}
\label{lst:grp.indef}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
La classe interna implementerà l'\,interfaccia di validazione, e, se definito
tramite interfaccia, l'\,interfaccia con la definizione del dettaglio dei campi
della classe interna.
Ogni gruppo è validabile singolarmente come se fosse una classe-dati.
L'\,interfaccia di validazione, \texttt{Validable}, richiede il metodo
\texttt{validateFails} che abbiamo già incontrato nella validazione della
classe-dati. Anche tutte le classi-dati implementano l'\,interfaccia 
\texttt{Validable}.

\begin{elisting}[!htb]
\begin{javacode}
public interface Validable {
    boolean validateFails(FieldValidateHandler handler);
}
\end{javacode}
\caption{Interfaccia di validazione, a livello classe-dati e gruppo}
\label{lst:if.validable}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
La definizione di un gruppo ripetuto è simile a qullo di un gruppo.
Viene creata una classe interna per gestire l'\,elemento 
intermedio ripetuto, un campo privato con $n$ istanze dell'\,elemento 
intermedio, un \textit{getter fluente} con un indice del campo, 
e un \textit{Consumer} con indice del campo.

\begin{elisting}[!htb]
\begin{javacode}
    public class TabError implements Validable, IError {/* ... */}
    private final TabError[] tabError = new TabError[] {
        this.new TabError(0),
        /* ... */
    };
    public TabError tabError(int k) { return this.tabError[k-1]; }
    public void withTabError(int k, WithAction<TabError> action) { action.accept(this.tabError[k-1]); }
\end{javacode}
\caption{Definizione di un gruppo ripetuto interno alla classe-dati}
\label{lst:occ.indef}
\end{elisting}

%--------1---------2---------3---------4---------5---------6---------7---------8
Anche in questo caso la classe interna che definisce l'\,elemento intermedio 
implementa l'\,interfaccia di validazione, e, se definito tramite interfaccia, 
l'\,interfaccia con la definizione del dettaglio dei campi della classe interna.



\iffalse
\begin{elisting}[!htb]
\begin{javacode}
    Foo311b foo = new Foo311b();
    foo.stopTime().setHours("01");
\end{javacode}
\caption{Setter di un campo all'\,interno di un gruppo}
\label{lst:grp.set}
\end{elisting}

\begin{elisting}[!htb]
\begin{javacode}
    Foo311b foo = new Foo311b();
    foo.withStopTime(stop -> {
        stop.setHours("01");
    });
\end{javacode}
\caption{Setter di un campo all'\,interno di un gruppo usando $\lambda$-function}
\label{lst:grp.withLambda}
\end{elisting}

\begin{elisting}[!htb]
\begin{javacode}
    Foo311b foo = new Foo311b();
    foo.withStopTime(new WithAction<Foo311b.StopTime>() {
        @Override
        public void call(Foo311b.StopTime stop) {
            stop.setHours("01");
        }
    });
\end{javacode}
\caption{Setter di un campo all'\,interno di un gruppo usando una funzione anonima}
\label{lst:grp.withAnonym}
\end{elisting}

\begin{elisting}[!htb]
\begin{javacode}
    Foo311b foo = new Foo311b();
    String hours = foo.stopTime().getHours();
\end{javacode}
\caption{Getter di un campo all'\,interno di un gruppo}
\label{lst:grp.get}
\end{elisting}

\begin{elisting}[!htb]
\begin{javacode}
    Foo311b foo = new Foo311b();
    boolean test = foo.validateFails(x -> System.out.println(x.message()));
\end{javacode}
\caption{Validazione di un gruppo}
\label{lst:grp.validate}
\end{elisting}
\fi

%\appendix
%\input{appe01.tex}

\clearpage
\listoffigures
\listoftables

\ifesource
\lstlistoflistings
\else
\listoflistings
\fi

\printindex

\end{document}
